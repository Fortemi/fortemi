# File/Attachment Provenance Tracking - Research Report

**Date**: 2026-02-01
**Author**: Research Agent (Claude Code)
**Status**: Research Complete

## Executive Summary

**Objective**: Design a provenance tracking system for file attachments in matric-memory that tracks creation, processing history, derivation chains, and optional access history.

**Recommendation**: **Database-centric with optional sidecar export**

**Confidence**: High

The research shows that for a knowledge management system like matric-memory, database tracking provides the best balance of queryability, integrity, and integration with existing provenance infrastructure.

---

## Current State: matric-memory Provenance

matric-memory already implements W3C PROV-O tracking for AI revisions:

### Existing Tables
1. **provenance_edge** - Tracks derivation relationships
   - revision_id → source_note_id (wasDerivedFrom)
   - Supports source_url for external sources
   - Relation types: wasDerivedFrom, used, wasInformedBy

2. **provenance_activity** - Tracks AI processing activities
   - Activity types: ai_revision, title_generation, context_update, concept_tagging
   - Records model_name, timestamps, metadata
   - Links to note_id and revision_id

3. **activity_log** - Audit trail
   - General activity logging
   - Actor, action, timestamps

### Gap Analysis
Current system tracks:
- AI content generation provenance
- Note revision history
- General audit activities

Missing for file attachments:
- Upload metadata (uploader, source location, original filename)
- Processing history (extraction, conversion, analysis)
- File-to-note derivation chains
- File version history
- Access patterns (optional)
- Storage location tracking

---

## Standards Analysis

### 1. W3C PROV-O (Primary Framework)

**Core Model**: Entity-Activity-Agent

**Key Classes**:
- **Entity**: The attachment itself (files, versions, derivatives)
- **Activity**: Operations on files (upload, process, extract, convert)
- **Agent**: Who/what performed the activity (user, AI model, system)

**Key Properties**:
- `prov:wasGeneratedBy` - File generated by upload/processing activity
- `prov:used` - Activity used source file
- `prov:wasAttributedTo` - File attributed to uploader/creator
- `prov:wasDerivedFrom` - Derived file from source file
- `prov:wasInformedBy` - Activity informed by previous activity
- `prov:atTime` - Temporal metadata
- `prov:hadRole` - Role in activity (input, output, parameter)

**Qualified Relations** (for detailed metadata):
- `prov:qualifiedGeneration` → Generation class
- `prov:qualifiedUsage` → Usage class
- `prov:qualifiedDerivation` → Derivation class

**Strengths**:
- Rich, formal ontology
- Handles complex provenance graphs
- Time-based queries
- Role-based tracking

**Weaknesses**:
- Complex for simple use cases
- Requires careful modeling

**References**:
- W3C PROV-O: https://www.w3.org/TR/prov-o/
- W3C PROV-DM: https://www.w3.org/TR/prov-dm/

### 2. Dublin Core Terms

**Relevant Terms**:
- `dcterms:creator` - Original creator
- `dcterms:contributor` - Secondary contributors
- `dcterms:created` - Creation timestamp
- `dcterms:modified` - Last modification
- `dcterms:provenance` - Free-text provenance statement
- `dcterms:source` - Source resource
- `dcterms:isVersionOf` - Version relationship
- `dcterms:replaces` - Replacement relationship

**Strengths**:
- Simple, widely adopted
- Good for basic metadata
- Interoperable

**Weaknesses**:
- Limited granularity
- No activity tracking
- Weak for complex lineage

**References**:
- Dublin Core Terms: https://www.dublincore.org/specifications/dublin-core/dcmi-terms/

### 3. DataCite Schema

**Relevant Elements**:
- `RelatedIdentifier` with relation types:
  - IsDerivedFrom
  - IsSourceOf
  - IsVersionOf
  - IsVariantFormOf
- `Contributor` types:
  - DataManager
  - DataCurator
- `RelatedItem` for publication chains

**Strengths**:
- Designed for scientific data
- Strong version tracking
- DOI integration

**Weaknesses**:
- Focused on published datasets
- Less suited for internal file management

**References**:
- DataCite Schema: https://schema.datacite.org/

### 4. Git Object Model

**Architecture**:
- Immutable commit objects
- Content-addressable storage (SHA-1/SHA-256)
- Parent references form DAG
- Separate author vs committer

**Metadata**:
```
tree <tree-sha>
parent <parent-sha>
author Name <email> timestamp timezone
committer Name <email> timestamp timezone

Commit message
```

**Strengths**:
- Proven at scale
- Cryptographic integrity
- Efficient storage (delta compression)
- Complete history

**Weaknesses**:
- Complex to implement
- Requires specialized storage
- Harder to query relationally

**References**:
- Git internals: https://git-scm.com/book/en/v2/Git-Internals-Git-Objects

---

## Implementation Pattern Comparison

### Database-Centric (RECOMMENDED)

**Architecture**:
- Dedicated tables for attachments, versions, activities
- References to existing provenance infrastructure
- Rich indexing for queries

**Pros**:
- Fast, flexible queries
- Referential integrity
- Transactional consistency
- Integrates with existing provenance_edge/activity tables
- Supports complex lineage queries
- Easy backup/restore

**Cons**:
- Requires database
- More complex schema
- Need separate file storage

**Best For**: matric-memory (structured data with rich queries)

### Sidecar Files

**Architecture**:
- Metadata in companion files (e.g., `document.pdf.prov.json`)
- Travels with file in filesystem
- JSON/XML format

**Pros**:
- Portable with file
- No database needed
- Simple implementation
- Works with any storage

**Cons**:
- Can get separated from file
- Hard to query across files
- Synchronization issues
- No referential integrity

**Best For**: Standalone tools, archival systems

### Embedded Metadata

**Architecture**:
- Metadata inside file (EXIF, XMP, custom chunks)
- Tightly coupled

**Pros**:
- Never separates
- Standard tools support
- Format-specific optimizations

**Cons**:
- Limited by format support
- Can bloat files
- Harder to update
- Not all formats support it

**Best For**: Images, media files with standard metadata

### Hybrid Approach

**Architecture**:
- Database for queries + sidecar for export
- Best of both worlds

**Pros**:
- Fast queries from DB
- Portable exports
- Flexible

**Cons**:
- More complex
- Synchronization overhead
- Duplication

**Best For**: Digital asset management, archives

---

## Recommended Architecture for matric-memory

### Schema Design

#### 1. Attachment Table (Core Entity)

```sql
CREATE TABLE attachment (
  id UUID PRIMARY KEY DEFAULT gen_uuid_v7(),

  -- Storage
  storage_key TEXT NOT NULL UNIQUE,        -- S3/filesystem key
  storage_provider TEXT NOT NULL,          -- 's3', 'local', 'gcs'

  -- File metadata
  original_filename TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes BIGINT NOT NULL,
  checksum_sha256 TEXT NOT NULL,           -- Content hash for integrity

  -- Ownership & timestamps
  owner_id UUID,                           -- User who owns this
  tenant_id UUID,                          -- Multi-tenant isolation
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Version tracking
  version INTEGER NOT NULL DEFAULT 1,
  parent_attachment_id UUID REFERENCES attachment(id),  -- Previous version
  is_current_version BOOLEAN NOT NULL DEFAULT TRUE,

  -- Soft delete
  deleted_at TIMESTAMPTZ,

  -- Extended metadata
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);

CREATE INDEX idx_attachment_owner ON attachment(owner_id) WHERE owner_id IS NOT NULL;
CREATE INDEX idx_attachment_tenant ON attachment(tenant_id) WHERE tenant_id IS NOT NULL;
CREATE INDEX idx_attachment_checksum ON attachment(checksum_sha256);
CREATE INDEX idx_attachment_parent ON attachment(parent_attachment_id);
CREATE INDEX idx_attachment_current ON attachment(id) WHERE is_current_version = TRUE;
CREATE INDEX idx_attachment_deleted ON attachment(deleted_at) WHERE deleted_at IS NULL;
CREATE INDEX idx_attachment_metadata ON attachment USING gin (metadata);

COMMENT ON TABLE attachment IS 'File attachments with version tracking and content-addressable storage';
COMMENT ON COLUMN attachment.storage_key IS 'Unique key in storage backend (path or object key)';
COMMENT ON COLUMN attachment.checksum_sha256 IS 'SHA-256 hash for integrity verification and deduplication';
```

#### 2. Attachment Upload Metadata (PROV Activity)

```sql
CREATE TABLE attachment_upload (
  id UUID PRIMARY KEY DEFAULT gen_uuid_v7(),
  attachment_id UUID NOT NULL REFERENCES attachment(id) ON DELETE CASCADE,

  -- WHO uploaded (PROV Agent)
  uploader_id UUID,                        -- User ID
  uploader_type TEXT NOT NULL DEFAULT 'user',  -- 'user', 'api', 'system'

  -- WHERE from (source provenance)
  source_type TEXT,                        -- 'local_file', 'url', 'clipboard', 'email', 'api'
  source_location TEXT,                    -- Original URL or path
  source_metadata JSONB DEFAULT '{}'::jsonb,

  -- WHEN (temporal metadata)
  uploaded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- HOW (upload method)
  upload_method TEXT,                      -- 'web_ui', 'api', 'mcp', 'email'
  client_info JSONB DEFAULT '{}'::jsonb,   -- User agent, IP, etc.

  UNIQUE(attachment_id)  -- One upload record per attachment
);

CREATE INDEX idx_attachment_upload_uploader ON attachment_upload(uploader_id);
CREATE INDEX idx_attachment_upload_time ON attachment_upload(uploaded_at DESC);

COMMENT ON TABLE attachment_upload IS 'W3C PROV: Upload activity metadata (prov:Activity)';
COMMENT ON COLUMN attachment_upload.uploader_id IS 'W3C PROV: Agent who uploaded (prov:wasAttributedTo)';
COMMENT ON COLUMN attachment_upload.source_location IS 'Original source for provenance (dcterms:source)';
```

#### 3. Attachment Processing History (PROV Activities)

```sql
CREATE TABLE attachment_processing (
  id UUID PRIMARY KEY DEFAULT gen_uuid_v7(),
  attachment_id UUID NOT NULL REFERENCES attachment(id) ON DELETE CASCADE,

  -- Processing activity
  activity_type TEXT NOT NULL,             -- 'text_extraction', 'thumbnail_generation',
                                           -- 'format_conversion', 'ai_analysis',
                                           -- 'ocr', 'embedding_generation'

  -- WHO/WHAT performed processing (PROV Agent)
  processor_type TEXT NOT NULL,            -- 'ai_model', 'system', 'user', 'service'
  processor_name TEXT,                     -- Model name or service name

  -- WHEN
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  duration_ms INTEGER,

  -- Status
  status TEXT NOT NULL DEFAULT 'pending',  -- 'pending', 'running', 'completed', 'failed'
  error_message TEXT,

  -- Input/Output (PROV used/wasGeneratedBy)
  input_metadata JSONB DEFAULT '{}'::jsonb,
  output_metadata JSONB DEFAULT '{}'::jsonb,

  -- Generated outputs
  output_attachment_id UUID REFERENCES attachment(id),  -- If processing creates new file
  output_note_id UUID REFERENCES note(id),              -- If processing creates note

  -- Processing config
  config JSONB DEFAULT '{}'::jsonb
);

CREATE INDEX idx_attachment_proc_attachment ON attachment_processing(attachment_id);
CREATE INDEX idx_attachment_proc_type ON attachment_processing(activity_type);
CREATE INDEX idx_attachment_proc_time ON attachment_processing(started_at DESC);
CREATE INDEX idx_attachment_proc_output_attachment ON attachment_processing(output_attachment_id);
CREATE INDEX idx_attachment_proc_output_note ON attachment_processing(output_note_id);

COMMENT ON TABLE attachment_processing IS 'W3C PROV: Processing activities on attachments';
COMMENT ON COLUMN attachment_processing.output_attachment_id IS 'Derived attachment (prov:wasDerivedFrom)';
COMMENT ON COLUMN attachment_processing.output_note_id IS 'Note generated from attachment (prov:wasGeneratedBy)';
```

#### 4. Attachment-Note Relationships (PROV Derivation)

```sql
CREATE TABLE attachment_note_link (
  id UUID PRIMARY KEY DEFAULT gen_uuid_v7(),
  attachment_id UUID NOT NULL REFERENCES attachment(id) ON DELETE CASCADE,
  note_id UUID NOT NULL REFERENCES note(id) ON DELETE CASCADE,

  -- Relationship type (PROV/Dublin Core inspired)
  relation_type TEXT NOT NULL,             -- 'attached_to', 'derived_from', 'mentioned_in',
                                           -- 'generated_from', 'source_for'

  -- Derivation specifics
  derivation_method TEXT,                  -- 'text_extraction', 'ai_summary', 'manual_transcription'
  processing_id UUID REFERENCES attachment_processing(id),  -- Link to processing activity

  -- WHO created link
  created_by UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Additional metadata
  metadata JSONB DEFAULT '{}'::jsonb,

  UNIQUE(attachment_id, note_id, relation_type)
);

CREATE INDEX idx_attachment_note_attachment ON attachment_note_link(attachment_id);
CREATE INDEX idx_attachment_note_note ON attachment_note_link(note_id);
CREATE INDEX idx_attachment_note_relation ON attachment_note_link(relation_type);
CREATE INDEX idx_attachment_note_processing ON attachment_note_link(processing_id);

COMMENT ON TABLE attachment_note_link IS 'W3C PROV: Derivation relationships between attachments and notes';
COMMENT ON COLUMN attachment_note_link.relation_type IS 'Provenance relation: attached_to, derived_from, generated_from';
```

#### 5. Attachment Access Log (Optional)

```sql
CREATE TABLE attachment_access_log (
  id UUID PRIMARY KEY DEFAULT gen_uuid_v7(),
  attachment_id UUID NOT NULL REFERENCES attachment(id) ON DELETE CASCADE,

  -- WHO accessed
  accessor_id UUID,
  accessor_type TEXT NOT NULL DEFAULT 'user',  -- 'user', 'system', 'api'

  -- WHEN
  accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- HOW
  access_type TEXT NOT NULL,               -- 'view', 'download', 'preview', 'process'
  access_method TEXT,                      -- 'web_ui', 'api', 'direct_link'

  -- Context
  client_info JSONB DEFAULT '{}'::jsonb,

  -- Performance (for analytics)
  response_time_ms INTEGER
);

-- Partitioned by time for large-scale access logging
CREATE INDEX idx_attachment_access_attachment ON attachment_access_log(attachment_id, accessed_at DESC);
CREATE INDEX idx_attachment_access_accessor ON attachment_access_log(accessor_id, accessed_at DESC);
CREATE INDEX idx_attachment_access_time ON attachment_access_log(accessed_at DESC);

COMMENT ON TABLE attachment_access_log IS 'Optional: Access audit trail for compliance and analytics';
```

#### 6. Integration with Existing Provenance

Extend existing `provenance_edge` to support attachments:

```sql
-- Add attachment support to existing provenance_edge
ALTER TABLE provenance_edge
  ADD COLUMN source_attachment_id UUID REFERENCES attachment(id) ON DELETE SET NULL;

CREATE INDEX idx_provenance_source_attachment ON provenance_edge(source_attachment_id);

COMMENT ON COLUMN provenance_edge.source_attachment_id IS 'Source attachment for derivation (e.g., note derived from PDF)';
```

---

## Provenance Queries

### Query 1: Full upload provenance for an attachment

```sql
SELECT
  a.id,
  a.original_filename,
  a.mime_type,
  a.checksum_sha256,
  au.uploader_id,
  au.source_type,
  au.source_location,
  au.uploaded_at,
  au.upload_method
FROM attachment a
JOIN attachment_upload au ON a.id = au.attachment_id
WHERE a.id = $1;
```

### Query 2: Processing history chain for an attachment

```sql
WITH RECURSIVE processing_chain AS (
  -- Base case: direct processing on attachment
  SELECT
    ap.id,
    ap.attachment_id,
    ap.activity_type,
    ap.processor_name,
    ap.started_at,
    ap.output_attachment_id,
    ap.output_note_id,
    1 as depth
  FROM attachment_processing ap
  WHERE ap.attachment_id = $1

  UNION ALL

  -- Recursive case: processing on derived attachments
  SELECT
    ap.id,
    ap.attachment_id,
    ap.activity_type,
    ap.processor_name,
    ap.started_at,
    ap.output_attachment_id,
    ap.output_note_id,
    pc.depth + 1
  FROM attachment_processing ap
  JOIN processing_chain pc ON ap.attachment_id = pc.output_attachment_id
  WHERE pc.depth < 10  -- Limit recursion
)
SELECT * FROM processing_chain
ORDER BY depth, started_at;
```

### Query 3: Derivation chain (attachment → note)

```sql
SELECT
  a.id as attachment_id,
  a.original_filename,
  anl.relation_type,
  anl.derivation_method,
  ap.activity_type,
  ap.processor_name,
  ap.started_at,
  n.id as note_id,
  n.title
FROM attachment a
JOIN attachment_note_link anl ON a.id = anl.attachment_id
JOIN note n ON anl.note_id = n.id
LEFT JOIN attachment_processing ap ON anl.processing_id = ap.id
WHERE a.id = $1;
```

### Query 4: Version history

```sql
WITH RECURSIVE version_chain AS (
  -- Start with current version
  SELECT
    id,
    original_filename,
    version,
    parent_attachment_id,
    created_at,
    1 as depth
  FROM attachment
  WHERE id = $1

  UNION ALL

  -- Walk back through parent versions
  SELECT
    a.id,
    a.original_filename,
    a.version,
    a.parent_attachment_id,
    a.created_at,
    vc.depth + 1
  FROM attachment a
  JOIN version_chain vc ON a.id = vc.parent_attachment_id
  WHERE vc.depth < 100
)
SELECT * FROM version_chain
ORDER BY version DESC;
```

### Query 5: Complete provenance graph (W3C PROV-style)

```sql
SELECT
  'attachment' as entity_type,
  a.id as entity_id,
  'wasUploadedBy' as relation,
  au.uploader_id as agent_id,
  au.uploaded_at as at_time,
  au.source_location as additional_info
FROM attachment a
JOIN attachment_upload au ON a.id = au.attachment_id
WHERE a.id = $1

UNION ALL

SELECT
  'attachment' as entity_type,
  ap.attachment_id as entity_id,
  'wasProcessedBy' as relation,
  ap.processor_name as agent_id,
  ap.started_at as at_time,
  ap.activity_type as additional_info
FROM attachment_processing ap
WHERE ap.attachment_id = $1

UNION ALL

SELECT
  'note' as entity_type,
  anl.note_id as entity_id,
  anl.relation_type as relation,
  ap.processor_name as agent_id,
  anl.created_at as at_time,
  anl.derivation_method as additional_info
FROM attachment_note_link anl
LEFT JOIN attachment_processing ap ON anl.processing_id = ap.id
WHERE anl.attachment_id = $1;
```

---

## Dublin Core Metadata Mapping

For interoperability, map matric-memory schema to Dublin Core terms:

| matric-memory field | Dublin Core term | Notes |
|---------------------|------------------|-------|
| attachment_upload.uploader_id | dcterms:creator | Original uploader |
| attachment.created_at | dcterms:created | Creation timestamp |
| attachment.metadata->last_modified | dcterms:modified | Last modification |
| attachment_upload.source_location | dcterms:source | Source provenance |
| attachment.parent_attachment_id | dcterms:isVersionOf | Version relationship |
| attachment_note_link (derived_from) | dcterms:source | Derivation source |
| attachment.metadata->description | dcterms:description | File description |
| attachment.mime_type | dcterms:format | File format |

### Export Example (Dublin Core XML)

```xml
<?xml version="1.0"?>
<metadata xmlns:dcterms="http://purl.org/dc/terms/">
  <dcterms:identifier>01933d5e-8b2a-7890-9abc-123456789abc</dcterms:identifier>
  <dcterms:title>Research Paper.pdf</dcterms:title>
  <dcterms:format>application/pdf</dcterms:format>
  <dcterms:creator>user:01933d5e-1234-5678-abcd-ef0123456789</dcterms:creator>
  <dcterms:created>2026-02-01T10:30:00Z</dcterms:created>
  <dcterms:source>https://arxiv.org/pdf/example.pdf</dcterms:source>
  <dcterms:provenance>
    Uploaded via web UI by user on 2026-02-01.
    Text extracted on 2026-02-01 using pdftotext.
    Embedded on 2026-02-01 using nomic-embed-text-v1.5.
  </dcterms:provenance>
</metadata>
```

---

## W3C PROV-O JSON-LD Export

For standards compliance, support PROV-O export:

```json
{
  "@context": "https://www.w3.org/ns/prov",
  "@graph": [
    {
      "@id": "attachment:01933d5e-8b2a-7890-9abc-123456789abc",
      "@type": "prov:Entity",
      "prov:wasGeneratedBy": "activity:upload-001",
      "prov:wasAttributedTo": "agent:user-123",
      "prov:generatedAtTime": "2026-02-01T10:30:00Z",
      "dcterms:format": "application/pdf",
      "custom:checksum": "sha256:abc123..."
    },
    {
      "@id": "activity:upload-001",
      "@type": "prov:Activity",
      "prov:wasAssociatedWith": "agent:user-123",
      "prov:used": {
        "@id": "source:https://arxiv.org/pdf/example.pdf"
      },
      "prov:startedAtTime": "2026-02-01T10:30:00Z",
      "prov:endedAtTime": "2026-02-01T10:30:05Z"
    },
    {
      "@id": "activity:text-extraction-001",
      "@type": "prov:Activity",
      "prov:used": "attachment:01933d5e-8b2a-7890-9abc-123456789abc",
      "prov:wasAssociatedWith": "agent:pdftotext",
      "prov:generated": "note:01933d5e-9999-7890-aaaa-111111111111",
      "prov:startedAtTime": "2026-02-01T10:31:00Z",
      "prov:endedAtTime": "2026-02-01T10:31:03Z"
    },
    {
      "@id": "note:01933d5e-9999-7890-aaaa-111111111111",
      "@type": "prov:Entity",
      "prov:wasDerivedFrom": "attachment:01933d5e-8b2a-7890-9abc-123456789abc",
      "prov:wasGeneratedBy": "activity:text-extraction-001"
    }
  ]
}
```

---

## Implementation Recommendations

### Phase 1: Core Provenance (MUST HAVE)

1. **attachment** table - core entity
2. **attachment_upload** table - who/when/where uploaded
3. **attachment_processing** table - processing history
4. **attachment_note_link** table - derivation to notes
5. **Extend provenance_edge** - integrate with existing system

### Phase 2: Enhanced Tracking (SHOULD HAVE)

6. Version history (parent_attachment_id chain)
7. Content-addressable storage (checksum deduplication)
8. Processing status tracking
9. Error handling and retry logic

### Phase 3: Advanced Features (NICE TO HAVE)

10. **attachment_access_log** - access audit trail
11. Dublin Core export API
12. PROV-O JSON-LD export
13. Sidecar file generation for export
14. Provenance visualization API

---

## Storage Strategy

### Content-Addressable Storage

Use SHA-256 hash as storage key for deduplication:

```
storage/
  ab/
    cd/
      abcdef123456789...full-sha256.pdf
```

**Benefits**:
- Automatic deduplication
- Integrity verification
- Immutable storage
- Git-like architecture

**Implementation**:
```sql
-- Function to generate storage path from checksum
CREATE OR REPLACE FUNCTION generate_storage_key(checksum TEXT, extension TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN
    substring(checksum, 1, 2) || '/' ||
    substring(checksum, 3, 2) || '/' ||
    checksum ||
    CASE WHEN extension IS NOT NULL THEN '.' || extension ELSE '' END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

### Metadata Storage

Store extended metadata in JSONB:

```json
{
  "dublin_core": {
    "description": "Research paper on provenance tracking",
    "subject": ["provenance", "W3C PROV", "metadata"],
    "language": "en"
  },
  "exif": {
    "created_date": "2026-01-15",
    "author": "Original Author"
  },
  "custom": {
    "project": "matric-memory",
    "importance": "high"
  }
}
```

---

## Security Considerations

### 1. Access Control

Inherit from note security model:
```sql
-- Add to attachment table
ALTER TABLE attachment
  ADD COLUMN visibility note_visibility DEFAULT 'private';

CREATE INDEX idx_attachment_visibility ON attachment(visibility);
```

### 2. Audit Requirements

For compliance (GDPR, HIPAA):
- Log all access (attachment_access_log)
- Track data lineage (provenance_edge)
- Support right-to-delete (soft delete with deleted_at)
- Export provenance on request (Dublin Core/PROV-O)

### 3. Privacy

- Anonymize client_info after retention period
- Optional access logging (disabled by default)
- User consent for detailed tracking

---

## Migration Path

### Step 1: Create Schema
Run migration with all tables

### Step 2: Backfill Existing Data
If attachments already exist:
```sql
INSERT INTO attachment_upload (attachment_id, uploader_id, uploaded_at, upload_method)
SELECT id, owner_id, created_at, 'legacy_import'
FROM attachment
WHERE id NOT IN (SELECT attachment_id FROM attachment_upload);
```

### Step 3: Update Application Code
- Modify upload handlers to create attachment_upload records
- Add processing hooks to create attachment_processing records
- Update note creation from attachments to link via attachment_note_link

### Step 4: Add Export APIs
- GET /attachments/{id}/provenance - full provenance graph
- GET /attachments/{id}/provenance.xml - Dublin Core XML
- GET /attachments/{id}/provenance.jsonld - PROV-O JSON-LD

---

## Alternative: Sidecar Files (Export Only)

For users who want portable provenance, generate sidecar files on export:

```bash
document.pdf
document.pdf.prov.json
```

**document.pdf.prov.json**:
```json
{
  "file": "document.pdf",
  "checksum": "sha256:abcdef...",
  "provenance": {
    "uploaded": {
      "by": "user@example.com",
      "at": "2026-02-01T10:30:00Z",
      "from": "https://example.com/source.pdf",
      "method": "web_ui"
    },
    "processing": [
      {
        "type": "text_extraction",
        "processor": "pdftotext",
        "at": "2026-02-01T10:31:00Z",
        "output": "note:01933d5e-9999-7890"
      }
    ],
    "derivations": [
      {
        "entity": "note:01933d5e-9999-7890",
        "type": "generated_from",
        "method": "text_extraction"
      }
    ]
  }
}
```

---

## Comparison with Industry Examples

### Example 1: Fedora Commons (Digital Repository)

**Approach**: Database + object store with RDF provenance

**Provenance Model**:
- PREMIS (Preservation Metadata)
- W3C PROV-O
- Fedora API-A for provenance export

**Strengths**: Rich metadata, standards-compliant
**Weaknesses**: Complex, heavyweight

**Relevance**: Similar use case, but matric-memory is lighter-weight

### Example 2: Apache Atlas (Data Governance)

**Approach**: Graph database for lineage tracking

**Provenance Model**:
- Custom type system
- Hooks into Spark/Hive for automatic lineage
- REST API for queries

**Strengths**: Automatic extraction, visual lineage
**Weaknesses**: Requires Hadoop ecosystem

**Relevance**: Good for automatic tracking patterns

### Example 3: Git LFS (Large File Storage)

**Approach**: Content-addressable storage with pointer files

**Provenance Model**:
- Git commits provide history
- SHA-256 for integrity
- Pointer files in Git repo

**Strengths**: Familiar Git workflow, efficient storage
**Weaknesses**: No activity tracking beyond commits

**Relevance**: Good model for content-addressable storage

---

## Success Metrics

### Implementation Success
- All attachments have provenance metadata
- Processing activities tracked automatically
- Derivation chains queryable in <100ms
- Zero orphaned files (referential integrity maintained)

### Usability Success
- Users can view "where did this come from?" in UI
- Export to Dublin Core/PROV-O works
- Provenance queries return results in <1s
- Version history navigable

### Compliance Success
- Audit trail complete for regulated data
- GDPR export includes provenance
- Right-to-delete cascades correctly
- Retention policies enforceable

---

## Conclusion

**Recommendation**: Implement database-centric provenance tracking with W3C PROV-O alignment.

**Key Benefits**:
1. Integrates seamlessly with existing matric-memory provenance infrastructure
2. Supports rich queries for lineage and derivation
3. Standards-compliant (W3C PROV-O, Dublin Core)
4. Scalable and performant
5. Optional sidecar export for portability

**Next Steps**:
1. Review and refine schema design
2. Create migration (20260202500000_attachment_provenance.sql)
3. Implement upload handlers
4. Add processing tracking hooks
5. Build provenance query APIs
6. Create UI for viewing provenance chains

---

## References

1. W3C PROV-O (Provenance Ontology): https://www.w3.org/TR/prov-o/
2. W3C PROV-DM (Provenance Data Model): https://www.w3.org/TR/prov-dm/
3. Dublin Core Metadata Terms: https://www.dublincore.org/specifications/dublin-core/dcmi-terms/
4. DataCite Metadata Schema: https://schema.datacite.org/
5. Git Internals - Git Objects: https://git-scm.com/book/en/v2/Git-Internals-Git-Objects
6. PREMIS Data Dictionary: https://www.loc.gov/standards/premis/
7. Apache Atlas: https://atlas.apache.org/
8. Git LFS: https://git-lfs.github.com/
