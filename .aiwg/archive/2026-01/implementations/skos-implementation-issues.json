[
  {
    "title": "DB: Create SKOS schema migration",
    "body": "## Description\n\nCreate PostgreSQL migration to implement W3C SKOS-compliant hierarchical tag system.\n\n## Acceptance Criteria\n\n- [ ] Migration file created: `migrations/YYYYMMDD_skos_schema.sql`\n- [ ] `skos_concept` table with id, notation, created_at, updated_at\n- [ ] `skos_label` table with concept_id, label_type (prefLabel/altLabel/hiddenLabel), language, value\n- [ ] `skos_concept_relationship` table with parent_id, child_id, relationship_type (broader/narrower/related)\n- [ ] `skos_scheme` table for concept schemes (namespaces)\n- [ ] `skos_concept_scheme` junction table\n- [ ] `skos_mapping` table for cross-scheme equivalence (exactMatch/closeMatch/relatedMatch)\n- [ ] Unique constraints on notation within scheme\n- [ ] Foreign key constraints with CASCADE deletes\n- [ ] Indices on: notation, label values (GIN for FTS), parent_id, child_id\n- [ ] Check constraint preventing self-referential relationships\n- [ ] Migration tested with rollback script\n\n## Migration Details\n\n```sql\n-- skos_scheme: namespaces for organizing concepts\nCREATE TABLE skos_scheme (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  notation TEXT NOT NULL UNIQUE,\n  title TEXT NOT NULL,\n  description TEXT,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- skos_concept: individual tag concepts\nCREATE TABLE skos_concept (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  notation TEXT NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(notation)\n);\n\n-- skos_label: multilingual labels for concepts\nCREATE TABLE skos_label (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  concept_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  label_type TEXT NOT NULL CHECK (label_type IN ('prefLabel', 'altLabel', 'hiddenLabel')),\n  language TEXT NOT NULL DEFAULT 'en',\n  value TEXT NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(concept_id, label_type, language)\n);\n\n-- skos_concept_relationship: hierarchical and associative relationships\nCREATE TABLE skos_concept_relationship (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  parent_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  child_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  relationship_type TEXT NOT NULL CHECK (relationship_type IN ('broader', 'narrower', 'related')),\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(parent_id, child_id, relationship_type),\n  CHECK (parent_id != child_id)\n);\n\n-- skos_concept_scheme: many-to-many for concepts in schemes\nCREATE TABLE skos_concept_scheme (\n  concept_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  scheme_id UUID NOT NULL REFERENCES skos_scheme(id) ON DELETE CASCADE,\n  is_top_concept BOOLEAN DEFAULT FALSE,\n  PRIMARY KEY (concept_id, scheme_id)\n);\n\n-- skos_mapping: cross-scheme concept mappings\nCREATE TABLE skos_mapping (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  source_concept_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  target_concept_id UUID NOT NULL REFERENCES skos_concept(id) ON DELETE CASCADE,\n  mapping_type TEXT NOT NULL CHECK (mapping_type IN ('exactMatch', 'closeMatch', 'relatedMatch', 'broadMatch', 'narrowMatch')),\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(source_concept_id, target_concept_id, mapping_type)\n);\n\n-- Indices\nCREATE INDEX idx_skos_concept_notation ON skos_concept(notation);\nCREATE INDEX idx_skos_label_concept ON skos_label(concept_id);\nCREATE INDEX idx_skos_label_value_fts ON skos_label USING gin(to_tsvector('english', value));\nCREATE INDEX idx_skos_relationship_parent ON skos_concept_relationship(parent_id);\nCREATE INDEX idx_skos_relationship_child ON skos_concept_relationship(child_id);\nCREATE INDEX idx_skos_concept_scheme_scheme ON skos_concept_scheme(scheme_id);\nCREATE INDEX idx_skos_concept_scheme_top ON skos_concept_scheme(scheme_id) WHERE is_top_concept = TRUE;\n```\n\n## Technical Notes\n\n- Follow deployment guide: backup database before running\n- Ensure pgvector extension already loaded\n- Use gen_random_uuid() for consistency with existing schema\n- Multilingual support via language column (ISO 639-1 codes)\n\n## Dependencies\n\nNone (foundational migration)\n\n## Estimated Effort\n\nMedium (4-6 hours)",
    "labels": ["database", "migration", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "DB: Migrate existing flat tags to SKOS concepts",
    "body": "## Description\n\nCreate migration to convert existing flat `tag` table entries to SKOS concepts while preserving note relationships.\n\n## Acceptance Criteria\n\n- [ ] Migration file: `migrations/YYYYMMDD_migrate_tags_to_skos.sql`\n- [ ] Default scheme created: 'default' or 'legacy'\n- [ ] Each existing tag.name becomes skos_concept.notation\n- [ ] Tag names become prefLabel entries in skos_label\n- [ ] All note_tag relationships updated to reference skos_concept.id\n- [ ] Preserve created_at timestamps\n- [ ] Handle duplicate tag names (case-insensitive)\n- [ ] Migration is idempotent (can run multiple times safely)\n- [ ] Rollback script provided\n- [ ] Data integrity validated (no orphaned relationships)\n\n## Migration Logic\n\n```sql\n-- Insert default scheme\nINSERT INTO skos_scheme (notation, title, description)\nVALUES ('legacy', 'Legacy Tags', 'Migrated from flat tag system')\nON CONFLICT (notation) DO NOTHING;\n\n-- Migrate tags to concepts\nINSERT INTO skos_concept (notation, created_at, updated_at)\nSELECT LOWER(name), created_at_utc, created_at_utc\nFROM tag\nON CONFLICT (notation) DO NOTHING;\n\n-- Create prefLabels\nINSERT INTO skos_label (concept_id, label_type, language, value)\nSELECT c.id, 'prefLabel', 'en', t.name\nFROM tag t\nJOIN skos_concept c ON LOWER(t.name) = c.notation\nON CONFLICT DO NOTHING;\n\n-- Link to default scheme\nINSERT INTO skos_concept_scheme (concept_id, scheme_id, is_top_concept)\nSELECT c.id, s.id, TRUE\nFROM skos_concept c\nCROSS JOIN skos_scheme s\nWHERE s.notation = 'legacy'\nON CONFLICT DO NOTHING;\n\n-- Update note_tag table structure (requires subsequent schema change)\n```\n\n## Technical Notes\n\n- Case normalization: use LOWER() for notation\n- Preserve original case in prefLabel\n- Handle empty/null tag names gracefully\n- Log migration statistics (count migrated, skipped, errors)\n\n## Dependencies\n\n- Issue #1: SKOS schema migration must be completed\n\n## Estimated Effort\n\nMedium (3-5 hours)",
    "labels": ["database", "migration", "data-migration", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "Core: Define SKOS Rust types and models",
    "body": "## Description\n\nDefine Rust types in `matric-core` for SKOS concepts, labels, relationships, schemes, and mappings.\n\n## Acceptance Criteria\n\n- [ ] `SkosScheme` struct in `crates/matric-core/src/models.rs`\n- [ ] `SkosConcept` struct with id, notation, created_at, updated_at\n- [ ] `SkosLabel` struct with concept_id, label_type enum, language, value\n- [ ] `SkosLabelType` enum: PrefLabel, AltLabel, HiddenLabel\n- [ ] `SkosRelationship` struct with parent_id, child_id, relationship_type enum\n- [ ] `SkosRelationshipType` enum: Broader, Narrower, Related\n- [ ] `SkosMapping` struct for cross-scheme mappings\n- [ ] `SkosMappingType` enum: ExactMatch, CloseMatch, RelatedMatch, BroadMatch, NarrowMatch\n- [ ] All types implement Serialize, Deserialize, Clone, Debug\n- [ ] sqlx FromRow derives where applicable\n- [ ] Validation methods on each type (e.g., notation format, language code)\n\n## Code Structure\n\n```rust\n// In crates/matric-core/src/models.rs\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SkosScheme {\n    pub id: Uuid,\n    pub notation: String,\n    pub title: String,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SkosConcept {\n    pub id: Uuid,\n    pub notation: String,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, sqlx::Type)]\n#[sqlx(type_name = \"text\", rename_all = \"camelCase\")]\npub enum SkosLabelType {\n    #[serde(rename = \"prefLabel\")]\n    PrefLabel,\n    #[serde(rename = \"altLabel\")]\n    AltLabel,\n    #[serde(rename = \"hiddenLabel\")]\n    HiddenLabel,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SkosLabel {\n    pub id: Uuid,\n    pub concept_id: Uuid,\n    pub label_type: SkosLabelType,\n    pub language: String,\n    pub value: String,\n    pub created_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, sqlx::Type)]\n#[sqlx(type_name = \"text\", rename_all = \"lowercase\")]\npub enum SkosRelationshipType {\n    Broader,\n    Narrower,\n    Related,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SkosRelationship {\n    pub id: Uuid,\n    pub parent_id: Uuid,\n    pub child_id: Uuid,\n    pub relationship_type: SkosRelationshipType,\n    pub created_at: DateTime<Utc>,\n}\n\nimpl SkosConcept {\n    pub fn validate_notation(notation: &str) -> Result<(), String> {\n        // Notation rules: lowercase, alphanumeric + hyphen/underscore, no spaces\n        // Pattern: ^[a-z0-9][a-z0-9_-]*$\n        if notation.is_empty() {\n            return Err(\"Notation cannot be empty\".to_string());\n        }\n        if !notation.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-' || c == '_') {\n            return Err(\"Notation must be lowercase alphanumeric with hyphens/underscores\".to_string());\n        }\n        Ok(())\n    }\n}\n```\n\n## Technical Notes\n\n- Use ISO 639-1 language codes (validate in SkosLabel)\n- Notation validation: lowercase, no spaces, alphanumeric + hyphen/underscore\n- Consider adding builder patterns for complex constructions\n\n## Dependencies\n\nNone (foundational types)\n\n## Estimated Effort\n\nSmall (2-3 hours)",
    "labels": ["core", "types", "priority-high", "size-S"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "DB: Implement SkosConceptRepository",
    "body": "## Description\n\nImplement repository pattern for SKOS concept CRUD operations in `matric-db` crate.\n\n## Acceptance Criteria\n\n- [ ] `SkosConceptRepository` trait in `crates/matric-db/src/repositories/mod.rs`\n- [ ] Implementation in `crates/matric-db/src/repositories/skos_concept.rs`\n- [ ] Methods:\n  - [ ] `create(concept, labels, scheme_id) -> Result<Uuid>`\n  - [ ] `get_by_id(id) -> Result<Option<ConceptWithLabels>>`\n  - [ ] `get_by_notation(notation) -> Result<Option<ConceptWithLabels>>`\n  - [ ] `update(id, notation, labels) -> Result<()>`\n  - [ ] `delete(id) -> Result<()>`\n  - [ ] `list_by_scheme(scheme_id, limit, offset) -> Result<Vec<ConceptWithLabels>>`\n  - [ ] `search_labels(query, scheme_id, limit) -> Result<Vec<ConceptWithLabels>>`\n- [ ] Struct `ConceptWithLabels` containing concept + Vec<SkosLabel>\n- [ ] Transaction support for create/update (concept + labels atomically)\n- [ ] Error handling with repository-specific errors\n- [ ] Unit tests with test database\n\n## Code Structure\n\n```rust\n// In crates/matric-db/src/repositories/skos_concept.rs\n\nuse crate::error::DbError;\nuse matric_core::models::{SkosConcept, SkosLabel, SkosLabelType};\nuse sqlx::{PgPool, Postgres, Transaction};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone)]\npub struct ConceptWithLabels {\n    pub concept: SkosConcept,\n    pub labels: Vec<SkosLabel>,\n}\n\npub struct SkosConceptRepository {\n    pool: PgPool,\n}\n\nimpl SkosConceptRepository {\n    pub fn new(pool: PgPool) -> Self {\n        Self { pool }\n    }\n\n    pub async fn create(\n        &self,\n        notation: String,\n        labels: Vec<(SkosLabelType, String, String)>,\n        scheme_id: Uuid,\n    ) -> Result<Uuid, DbError> {\n        let mut tx = self.pool.begin().await?;\n        \n        // Insert concept\n        let concept_id = sqlx::query_scalar(\n            \"INSERT INTO skos_concept (notation) VALUES ($1) RETURNING id\"\n        )\n        .bind(&notation)\n        .fetch_one(&mut *tx)\n        .await?;\n        \n        // Insert labels\n        for (label_type, language, value) in labels {\n            sqlx::query(\n                \"INSERT INTO skos_label (concept_id, label_type, language, value) VALUES ($1, $2, $3, $4)\"\n            )\n            .bind(concept_id)\n            .bind(label_type)\n            .bind(&language)\n            .bind(&value)\n            .execute(&mut *tx)\n            .await?;\n        }\n        \n        // Link to scheme\n        sqlx::query(\n            \"INSERT INTO skos_concept_scheme (concept_id, scheme_id) VALUES ($1, $2)\"\n        )\n        .bind(concept_id)\n        .bind(scheme_id)\n        .execute(&mut *tx)\n        .await?;\n        \n        tx.commit().await?;\n        Ok(concept_id)\n    }\n\n    pub async fn get_by_notation(\n        &self,\n        notation: &str,\n    ) -> Result<Option<ConceptWithLabels>, DbError> {\n        let concept = sqlx::query_as::<_, SkosConcept>(\n            \"SELECT * FROM skos_concept WHERE notation = $1\"\n        )\n        .bind(notation)\n        .fetch_optional(&self.pool)\n        .await?;\n        \n        if let Some(concept) = concept {\n            let labels = sqlx::query_as::<_, SkosLabel>(\n                \"SELECT * FROM skos_label WHERE concept_id = $1\"\n            )\n            .bind(concept.id)\n            .fetch_all(&self.pool)\n            .await?;\n            \n            Ok(Some(ConceptWithLabels { concept, labels }))\n        } else {\n            Ok(None)\n        }\n    }\n    \n    // Additional methods...\n}\n```\n\n## Technical Notes\n\n- Use transactions for atomicity\n- Implement soft deletes if needed (check existing patterns)\n- Consider caching for frequently accessed concepts\n\n## Dependencies\n\n- Issue #1: SKOS schema migration\n- Issue #3: SKOS Rust types\n\n## Estimated Effort\n\nMedium (6-8 hours)",
    "labels": ["database", "repository", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "DB: Implement hierarchy traversal queries",
    "body": "## Description\n\nImplement recursive CTE queries for SKOS concept hierarchy traversal (ancestors, descendants, tree).\n\n## Acceptance Criteria\n\n- [ ] Methods in `SkosConceptRepository`:\n  - [ ] `get_ancestors(concept_id, max_depth) -> Result<Vec<SkosConcept>>`\n  - [ ] `get_descendants(concept_id, max_depth) -> Result<Vec<SkosConcept>>`\n  - [ ] `get_siblings(concept_id) -> Result<Vec<SkosConcept>>`\n  - [ ] `get_tree(root_concept_id, max_depth) -> Result<ConceptTree>`\n  - [ ] `get_path_to_root(concept_id) -> Result<Vec<SkosConcept>>`\n- [ ] `ConceptTree` struct with recursive children\n- [ ] Recursive CTEs for efficient traversal\n- [ ] Cycle detection in relationships\n- [ ] Depth limiting to prevent runaway queries\n- [ ] Performance optimized with appropriate indices\n- [ ] Unit tests covering edge cases (cycles, orphans, deep trees)\n\n## Implementation Details\n\n```rust\n// In crates/matric-db/src/repositories/skos_concept.rs\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConceptTree {\n    pub concept: SkosConcept,\n    pub labels: Vec<SkosLabel>,\n    pub children: Vec<ConceptTree>,\n    pub depth: i32,\n}\n\nimpl SkosConceptRepository {\n    pub async fn get_ancestors(\n        &self,\n        concept_id: Uuid,\n        max_depth: Option<i32>,\n    ) -> Result<Vec<SkosConcept>, DbError> {\n        let depth_limit = max_depth.unwrap_or(10);\n        \n        let ancestors = sqlx::query_as::<_, SkosConcept>(\n            r#\"\n            WITH RECURSIVE ancestors AS (\n                SELECT c.*, 0 as depth\n                FROM skos_concept c\n                WHERE c.id = $1\n                \n                UNION ALL\n                \n                SELECT c.*, a.depth + 1\n                FROM skos_concept c\n                JOIN skos_concept_relationship r ON r.parent_id = c.id\n                JOIN ancestors a ON a.id = r.child_id\n                WHERE a.depth < $2\n                  AND r.relationship_type = 'broader'\n            )\n            SELECT id, notation, created_at, updated_at\n            FROM ancestors\n            WHERE depth > 0\n            ORDER BY depth ASC\n            \"#\n        )\n        .bind(concept_id)\n        .bind(depth_limit)\n        .fetch_all(&self.pool)\n        .await?;\n        \n        Ok(ancestors)\n    }\n\n    pub async fn get_descendants(\n        &self,\n        concept_id: Uuid,\n        max_depth: Option<i32>,\n    ) -> Result<Vec<SkosConcept>, DbError> {\n        let depth_limit = max_depth.unwrap_or(10);\n        \n        let descendants = sqlx::query_as::<_, SkosConcept>(\n            r#\"\n            WITH RECURSIVE descendants AS (\n                SELECT c.*, 0 as depth\n                FROM skos_concept c\n                WHERE c.id = $1\n                \n                UNION ALL\n                \n                SELECT c.*, d.depth + 1\n                FROM skos_concept c\n                JOIN skos_concept_relationship r ON r.child_id = c.id\n                JOIN descendants d ON d.id = r.parent_id\n                WHERE d.depth < $2\n                  AND r.relationship_type = 'narrower'\n            )\n            SELECT id, notation, created_at, updated_at\n            FROM descendants\n            WHERE depth > 0\n            ORDER BY depth ASC\n            \"#\n        )\n        .bind(concept_id)\n        .bind(depth_limit)\n        .fetch_all(&self.pool)\n        .await?;\n        \n        Ok(descendants)\n    }\n    \n    pub async fn get_tree(\n        &self,\n        root_concept_id: Uuid,\n        max_depth: Option<i32>,\n    ) -> Result<ConceptTree, DbError> {\n        // Recursive tree building logic\n        // Fetch root, then recursively fetch children\n        unimplemented!(\"Tree building logic\")\n    }\n}\n```\n\n## Technical Notes\n\n- Use WITH RECURSIVE for PostgreSQL CTEs\n- Limit depth to prevent infinite loops (default: 10)\n- Consider materialized path or nested sets for read-heavy workloads\n- Cache frequently accessed trees\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n\n## Estimated Effort\n\nMedium (5-7 hours)",
    "labels": ["database", "query-optimization", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "DB: Implement label search with autocomplete",
    "body": "## Description\n\nImplement fuzzy search and autocomplete for SKOS labels (prefLabel, altLabel) with FTS support.\n\n## Acceptance Criteria\n\n- [ ] Method `search_labels(query, scheme_id, lang, limit) -> Result<Vec<ConceptWithLabels>>`\n- [ ] Full-text search using PostgreSQL tsvector index\n- [ ] Support for partial matches (prefix matching)\n- [ ] Search across prefLabel and altLabel (not hiddenLabel)\n- [ ] Language filtering (default: 'en')\n- [ ] Scheme filtering (optional)\n- [ ] Ranking by relevance (ts_rank)\n- [ ] Fuzzy matching with pg_trgm extension (similarity)\n- [ ] Performance: <50ms for 10k concepts\n- [ ] Return matched label alongside concept\n- [ ] Unit tests with various query patterns\n\n## Implementation\n\n```rust\n// In crates/matric-db/src/repositories/skos_concept.rs\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct ConceptSearchResult {\n    #[sqlx(flatten)]\n    pub concept: SkosConcept,\n    pub matched_label: String,\n    pub label_type: SkosLabelType,\n    pub rank: f32,\n}\n\nimpl SkosConceptRepository {\n    pub async fn search_labels(\n        &self,\n        query: &str,\n        scheme_id: Option<Uuid>,\n        language: Option<&str>,\n        limit: i64,\n    ) -> Result<Vec<ConceptSearchResult>, DbError> {\n        let lang = language.unwrap_or(\"en\");\n        \n        let mut sql = r#\"\n            SELECT \n                c.id, c.notation, c.created_at, c.updated_at,\n                l.value as matched_label,\n                l.label_type,\n                ts_rank(to_tsvector('english', l.value), plainto_tsquery('english', $1)) as rank\n            FROM skos_concept c\n            JOIN skos_label l ON l.concept_id = c.id\n        \"#.to_string();\n        \n        if scheme_id.is_some() {\n            sql.push_str(\" JOIN skos_concept_scheme cs ON cs.concept_id = c.id\");\n        }\n        \n        sql.push_str(\" WHERE l.language = $2\");\n        sql.push_str(\" AND l.label_type IN ('prefLabel', 'altLabel')\");\n        sql.push_str(\" AND to_tsvector('english', l.value) @@ plainto_tsquery('english', $1)\");\n        \n        if scheme_id.is_some() {\n            sql.push_str(\" AND cs.scheme_id = $3\");\n        }\n        \n        sql.push_str(\" ORDER BY rank DESC, l.label_type ASC\");\n        sql.push_str(\" LIMIT $4\");\n        \n        let mut query_builder = sqlx::query_as::<_, ConceptSearchResult>(&sql)\n            .bind(query)\n            .bind(lang);\n            \n        if let Some(sid) = scheme_id {\n            query_builder = query_builder.bind(sid);\n        }\n        \n        let results = query_builder\n            .bind(limit)\n            .fetch_all(&self.pool)\n            .await?;\n        \n        Ok(results)\n    }\n    \n    pub async fn autocomplete(\n        &self,\n        prefix: &str,\n        scheme_id: Option<Uuid>,\n        limit: i64,\n    ) -> Result<Vec<String>, DbError> {\n        // Prefix matching for autocomplete\n        let pattern = format!(\"{}%\", prefix);\n        \n        let mut sql = r#\"\n            SELECT DISTINCT l.value\n            FROM skos_label l\n        \"#.to_string();\n        \n        if scheme_id.is_some() {\n            sql.push_str(\" JOIN skos_concept_scheme cs ON cs.concept_id = l.concept_id\");\n        }\n        \n        sql.push_str(\" WHERE l.value ILIKE $1\");\n        sql.push_str(\" AND l.label_type = 'prefLabel'\");\n        \n        if scheme_id.is_some() {\n            sql.push_str(\" AND cs.scheme_id = $2\");\n        }\n        \n        sql.push_str(\" ORDER BY l.value ASC LIMIT $3\");\n        \n        let mut query_builder = sqlx::query_scalar(&sql).bind(&pattern);\n        \n        if let Some(sid) = scheme_id {\n            query_builder = query_builder.bind(sid);\n        }\n        \n        let results = query_builder\n            .bind(limit)\n            .fetch_all(&self.pool)\n            .await?;\n        \n        Ok(results)\n    }\n}\n```\n\n## Technical Notes\n\n- Already have GIN index on skos_label from migration\n- Consider pg_trgm for typo tolerance (needs extension)\n- Cache popular searches\n- Prioritize prefLabel over altLabel in ranking\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n\n## Estimated Effort\n\nSmall (3-4 hours)",
    "labels": ["database", "search", "priority-medium", "size-S"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "Core: Implement validation types and anti-pattern detection",
    "body": "## Description\n\nDefine validation rules and anti-pattern detection for SKOS hierarchies.\n\n## Acceptance Criteria\n\n- [ ] `SkosValidator` struct in `crates/matric-core/src/validation.rs`\n- [ ] Validation rules:\n  - [ ] Max depth limit (configurable, default: 5)\n  - [ ] Max breadth per node (configurable, default: 20)\n  - [ ] Notation format validation (lowercase, alphanumeric, hyphen/underscore)\n  - [ ] Language code validation (ISO 639-1)\n  - [ ] Unique prefLabel per concept per language\n- [ ] Anti-pattern detection:\n  - [ ] Over-nesting (depth > threshold)\n  - [ ] Meta-tags (tags about tags, e.g., \"tag-management\")\n  - [ ] Orphan concepts (no parent, not top concept)\n  - [ ] Cycles in hierarchy\n  - [ ] Too many siblings (breadth > threshold)\n  - [ ] Single-child parents (unnecessary nesting)\n  - [ ] Duplicate labels across concepts\n- [ ] `ValidationResult` type with warnings and errors\n- [ ] Unit tests for each validation rule\n\n## Code Structure\n\n```rust\n// In crates/matric-core/src/validation.rs\n\nuse crate::models::{SkosConcept, SkosLabel, SkosRelationship};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ValidationConfig {\n    pub max_depth: usize,\n    pub max_breadth: usize,\n    pub allow_orphans: bool,\n    pub allow_single_child_parents: bool,\n}\n\nimpl Default for ValidationConfig {\n    fn default() -> Self {\n        Self {\n            max_depth: 5,\n            max_breadth: 20,\n            allow_orphans: false,\n            allow_single_child_parents: true,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ValidationLevel {\n    Error,\n    Warning,\n    Info,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ValidationIssue {\n    pub level: ValidationLevel,\n    pub code: String,\n    pub message: String,\n    pub concept_id: Option<Uuid>,\n    pub notation: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ValidationResult {\n    pub valid: bool,\n    pub issues: Vec<ValidationIssue>,\n}\n\nimpl ValidationResult {\n    pub fn new() -> Self {\n        Self {\n            valid: true,\n            issues: Vec::new(),\n        }\n    }\n    \n    pub fn add_error(&mut self, code: String, message: String, concept_id: Option<Uuid>) {\n        self.valid = false;\n        self.issues.push(ValidationIssue {\n            level: ValidationLevel::Error,\n            code,\n            message,\n            concept_id,\n            notation: None,\n        });\n    }\n    \n    pub fn add_warning(&mut self, code: String, message: String, concept_id: Option<Uuid>) {\n        self.issues.push(ValidationIssue {\n            level: ValidationLevel::Warning,\n            code,\n            message,\n            concept_id,\n            notation: None,\n        });\n    }\n}\n\npub struct SkosValidator {\n    config: ValidationConfig,\n}\n\nimpl SkosValidator {\n    pub fn new(config: ValidationConfig) -> Self {\n        Self { config }\n    }\n    \n    pub fn validate_notation(&self, notation: &str) -> Result<(), String> {\n        SkosConcept::validate_notation(notation)\n    }\n    \n    pub fn detect_over_nesting(&self, depth: usize, concept_id: Uuid) -> Option<ValidationIssue> {\n        if depth > self.config.max_depth {\n            Some(ValidationIssue {\n                level: ValidationLevel::Warning,\n                code: \"OVER_NESTING\".to_string(),\n                message: format!(\"Concept depth {} exceeds recommended maximum {}\", depth, self.config.max_depth),\n                concept_id: Some(concept_id),\n                notation: None,\n            })\n        } else {\n            None\n        }\n    }\n    \n    pub fn detect_too_many_siblings(&self, sibling_count: usize, parent_id: Uuid) -> Option<ValidationIssue> {\n        if sibling_count > self.config.max_breadth {\n            Some(ValidationIssue {\n                level: ValidationLevel::Warning,\n                code: \"TOO_MANY_SIBLINGS\".to_string(),\n                message: format!(\"Parent has {} children, exceeds recommended maximum {}\", sibling_count, self.config.max_breadth),\n                concept_id: Some(parent_id),\n                notation: None,\n            })\n        } else {\n            None\n        }\n    }\n    \n    pub fn detect_meta_tags(&self, notation: &str, labels: &[SkosLabel]) -> Option<ValidationIssue> {\n        let meta_patterns = [\"tag-\", \"taxonomy-\", \"category-\", \"classification-\"];\n        \n        if meta_patterns.iter().any(|p| notation.starts_with(p)) {\n            return Some(ValidationIssue {\n                level: ValidationLevel::Warning,\n                code: \"META_TAG\".to_string(),\n                message: format!(\"Notation '{}' appears to be a meta-tag (tag about tags)\", notation),\n                concept_id: None,\n                notation: Some(notation.to_string()),\n            });\n        }\n        \n        None\n    }\n    \n    // Additional validation methods...\n}\n```\n\n## Technical Notes\n\n- Validation should be non-blocking (warnings vs errors)\n- Consider performance for large hierarchies\n- Make thresholds configurable via user_config table\n\n## Dependencies\n\n- Issue #3: SKOS Rust types\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["core", "validation", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement concept CRUD endpoints",
    "body": "## Description\n\nCreate REST API endpoints for SKOS concept management in `matric-api`.\n\n## Acceptance Criteria\n\n- [ ] Routes in `crates/matric-api/src/routes/skos.rs`:\n  - [ ] `POST /api/v1/concepts` - Create concept with labels\n  - [ ] `GET /api/v1/concepts/:id` - Get concept by ID with labels\n  - [ ] `GET /api/v1/concepts/notation/:notation` - Get by notation\n  - [ ] `PUT /api/v1/concepts/:id` - Update concept and labels\n  - [ ] `DELETE /api/v1/concepts/:id` - Delete concept\n  - [ ] `GET /api/v1/concepts` - List concepts with pagination\n- [ ] Request/response DTOs in `crates/matric-api/src/dto/skos.rs`\n- [ ] Input validation (notation format, label constraints)\n- [ ] Error handling with appropriate HTTP status codes\n- [ ] OpenAPI/Swagger documentation\n- [ ] Integration tests\n\n## API Specification\n\n```rust\n// In crates/matric-api/src/dto/skos.rs\n\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\nuse matric_core::models::{SkosLabelType};\n\n#[derive(Debug, Deserialize)]\npub struct CreateConceptRequest {\n    pub notation: String,\n    pub scheme_id: Uuid,\n    pub labels: Vec<CreateLabelRequest>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct CreateLabelRequest {\n    pub label_type: SkosLabelType,\n    pub language: String,\n    pub value: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct ConceptResponse {\n    pub id: Uuid,\n    pub notation: String,\n    pub labels: Vec<LabelResponse>,\n    pub created_at: String,\n    pub updated_at: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct LabelResponse {\n    pub id: Uuid,\n    pub label_type: SkosLabelType,\n    pub language: String,\n    pub value: String,\n}\n\n// In crates/matric-api/src/routes/skos.rs\n\nuse axum::{\n    extract::{Path, Query, State},\n    http::StatusCode,\n    response::IntoResponse,\n    Json, Router,\n    routing::{get, post, put, delete},\n};\nuse crate::dto::skos::*;\nuse crate::AppState;\n\npub fn routes() -> Router<AppState> {\n    Router::new()\n        .route(\"/concepts\", post(create_concept).get(list_concepts))\n        .route(\"/concepts/:id\", get(get_concept).put(update_concept).delete(delete_concept))\n        .route(\"/concepts/notation/:notation\", get(get_concept_by_notation))\n}\n\nasync fn create_concept(\n    State(state): State<AppState>,\n    Json(req): Json<CreateConceptRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Validate notation\n    SkosConcept::validate_notation(&req.notation)\n        .map_err(|e| ApiError::validation(e))?;\n    \n    // Validate at least one prefLabel\n    if !req.labels.iter().any(|l| l.label_type == SkosLabelType::PrefLabel) {\n        return Err(ApiError::validation(\"At least one prefLabel is required\"));\n    }\n    \n    // Create concept\n    let labels: Vec<_> = req.labels.iter()\n        .map(|l| (l.label_type, l.language.clone(), l.value.clone()))\n        .collect();\n    \n    let concept_id = state.skos_repo\n        .create(req.notation, labels, req.scheme_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    // Fetch created concept\n    let concept = state.skos_repo\n        .get_by_id(concept_id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Concept not found\"))?;\n    \n    let response = ConceptResponse::from(concept);\n    \n    Ok((StatusCode::CREATED, Json(response)))\n}\n\nasync fn get_concept(\n    State(state): State<AppState>,\n    Path(id): Path<Uuid>,\n) -> Result<impl IntoResponse, ApiError> {\n    let concept = state.skos_repo\n        .get_by_id(id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Concept not found\"))?;\n    \n    Ok(Json(ConceptResponse::from(concept)))\n}\n\n// Additional handlers...\n```\n\n## Technical Notes\n\n- Follow existing API patterns in matric-api\n- Use Axum extractors for validation\n- Return 201 Created with Location header on POST\n- Return 404 for not found, 400 for validation errors\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n- Issue #3: SKOS Rust types\n\n## Estimated Effort\n\nMedium (6-8 hours)",
    "labels": ["api", "endpoints", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement search and autocomplete endpoints",
    "body": "## Description\n\nCreate REST API endpoints for SKOS label search and autocomplete.\n\n## Acceptance Criteria\n\n- [ ] Routes:\n  - [ ] `GET /api/v1/concepts/search?q=query&scheme_id=&lang=&limit=` - Full-text search\n  - [ ] `GET /api/v1/concepts/autocomplete?prefix=&scheme_id=&limit=` - Autocomplete\n- [ ] Query parameter validation\n- [ ] Response includes matched labels and relevance scores\n- [ ] Default limit: 20, max limit: 100\n- [ ] Performance: <100ms for typical queries\n- [ ] OpenAPI documentation\n- [ ] Integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/routes/skos.rs\n\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\npub struct SearchQuery {\n    pub q: String,\n    pub scheme_id: Option<Uuid>,\n    pub lang: Option<String>,\n    #[serde(default = \"default_limit\")]\n    pub limit: i64,\n}\n\nfn default_limit() -> i64 {\n    20\n}\n\n#[derive(Debug, Deserialize)]\npub struct AutocompleteQuery {\n    pub prefix: String,\n    pub scheme_id: Option<Uuid>,\n    #[serde(default = \"default_limit\")]\n    pub limit: i64,\n}\n\n#[derive(Debug, Serialize)]\npub struct SearchResultResponse {\n    pub concept: ConceptResponse,\n    pub matched_label: String,\n    pub label_type: SkosLabelType,\n    pub rank: f32,\n}\n\nasync fn search_concepts(\n    State(state): State<AppState>,\n    Query(params): Query<SearchQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Validate limit\n    let limit = params.limit.min(100).max(1);\n    \n    let results = state.skos_repo\n        .search_labels(\n            &params.q,\n            params.scheme_id,\n            params.lang.as_deref(),\n            limit,\n        )\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    let response: Vec<SearchResultResponse> = results.into_iter()\n        .map(SearchResultResponse::from)\n        .collect();\n    \n    Ok(Json(response))\n}\n\nasync fn autocomplete_concepts(\n    State(state): State<AppState>,\n    Query(params): Query<AutocompleteQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Validate limit and prefix\n    let limit = params.limit.min(100).max(1);\n    \n    if params.prefix.len() < 2 {\n        return Err(ApiError::validation(\"Prefix must be at least 2 characters\"));\n    }\n    \n    let results = state.skos_repo\n        .autocomplete(&params.prefix, params.scheme_id, limit)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    Ok(Json(results))\n}\n\npub fn routes() -> Router<AppState> {\n    Router::new()\n        // ... existing routes\n        .route(\"/concepts/search\", get(search_concepts))\n        .route(\"/concepts/autocomplete\", get(autocomplete_concepts))\n}\n```\n\n## Technical Notes\n\n- Minimum prefix length: 2 characters for autocomplete\n- Consider caching popular searches\n- Add rate limiting for search endpoints\n\n## Dependencies\n\n- Issue #6: Label search implementation\n- Issue #8: Concept CRUD endpoints\n\n## Estimated Effort\n\nSmall (3-4 hours)",
    "labels": ["api", "search", "priority-medium", "size-S"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement hierarchy tree endpoints",
    "body": "## Description\n\nCreate REST API endpoints for retrieving SKOS concept hierarchies.\n\n## Acceptance Criteria\n\n- [ ] Routes:\n  - [ ] `GET /api/v1/concepts/:id/ancestors` - Get ancestor chain\n  - [ ] `GET /api/v1/concepts/:id/descendants` - Get descendants\n  - [ ] `GET /api/v1/concepts/:id/siblings` - Get siblings\n  - [ ] `GET /api/v1/concepts/:id/tree?depth=` - Get tree from concept\n  - [ ] `GET /api/v1/schemes/:id/tree?depth=` - Get full scheme tree\n- [ ] Query parameters: max_depth (default: 5, max: 10)\n- [ ] Response includes depth/level information\n- [ ] Circular reference prevention\n- [ ] Performance optimized with proper caching\n- [ ] OpenAPI documentation\n- [ ] Integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/dto/skos.rs\n\n#[derive(Debug, Serialize)]\npub struct ConceptTreeResponse {\n    pub concept: ConceptResponse,\n    pub children: Vec<ConceptTreeResponse>,\n    pub depth: i32,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TreeQuery {\n    #[serde(default = \"default_tree_depth\")]\n    pub depth: i32,\n}\n\nfn default_tree_depth() -> i32 {\n    5\n}\n\n// In crates/matric-api/src/routes/skos.rs\n\nasync fn get_ancestors(\n    State(state): State<AppState>,\n    Path(id): Path<Uuid>,\n    Query(params): Query<TreeQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    let max_depth = params.depth.min(10).max(1);\n    \n    let ancestors = state.skos_repo\n        .get_ancestors(id, Some(max_depth))\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    let response: Vec<ConceptResponse> = ancestors.into_iter()\n        .map(ConceptResponse::from)\n        .collect();\n    \n    Ok(Json(response))\n}\n\nasync fn get_concept_tree(\n    State(state): State<AppState>,\n    Path(id): Path<Uuid>,\n    Query(params): Query<TreeQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    let max_depth = params.depth.min(10).max(1);\n    \n    let tree = state.skos_repo\n        .get_tree(id, Some(max_depth))\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    Ok(Json(ConceptTreeResponse::from(tree)))\n}\n\nasync fn get_scheme_tree(\n    State(state): State<AppState>,\n    Path(scheme_id): Path<Uuid>,\n    Query(params): Query<TreeQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    let max_depth = params.depth.min(10).max(1);\n    \n    // Get all top concepts for the scheme\n    let top_concepts = state.skos_repo\n        .get_top_concepts(scheme_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    // Build tree for each top concept\n    let mut trees = Vec::new();\n    for concept in top_concepts {\n        let tree = state.skos_repo\n            .get_tree(concept.id, Some(max_depth))\n            .await\n            .map_err(ApiError::from_db)?;\n        trees.push(ConceptTreeResponse::from(tree));\n    }\n    \n    Ok(Json(trees))\n}\n\npub fn routes() -> Router<AppState> {\n    Router::new()\n        // ... existing routes\n        .route(\"/concepts/:id/ancestors\", get(get_ancestors))\n        .route(\"/concepts/:id/descendants\", get(get_descendants))\n        .route(\"/concepts/:id/siblings\", get(get_siblings))\n        .route(\"/concepts/:id/tree\", get(get_concept_tree))\n        .route(\"/schemes/:id/tree\", get(get_scheme_tree))\n}\n```\n\n## Technical Notes\n\n- Cache tree responses with TTL (e.g., 5 minutes)\n- Consider lazy loading for large trees (virtualization)\n- Return depth information for UI rendering\n\n## Dependencies\n\n- Issue #5: Hierarchy traversal queries\n- Issue #8: Concept CRUD endpoints\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["api", "hierarchy", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement relationship management endpoints",
    "body": "## Description\n\nCreate REST API endpoints for managing SKOS concept relationships (broader/narrower/related).\n\n## Acceptance Criteria\n\n- [ ] Routes:\n  - [ ] `POST /api/v1/concepts/:id/relationships` - Add relationship\n  - [ ] `GET /api/v1/concepts/:id/relationships` - List relationships\n  - [ ] `DELETE /api/v1/concepts/:id/relationships/:relationship_id` - Remove relationship\n- [ ] Support for relationship types: broader, narrower, related\n- [ ] Automatic inverse relationship creation (broader <-> narrower)\n- [ ] Cycle detection before creating relationships\n- [ ] Validation: prevent self-relationships\n- [ ] Transaction support for inverse relationships\n- [ ] OpenAPI documentation\n- [ ] Integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/dto/skos.rs\n\n#[derive(Debug, Deserialize)]\npub struct CreateRelationshipRequest {\n    pub target_concept_id: Uuid,\n    pub relationship_type: SkosRelationshipType,\n}\n\n#[derive(Debug, Serialize)]\npub struct RelationshipResponse {\n    pub id: Uuid,\n    pub parent_id: Uuid,\n    pub child_id: Uuid,\n    pub relationship_type: SkosRelationshipType,\n    pub created_at: String,\n}\n\n// In crates/matric-api/src/routes/skos.rs\n\nasync fn create_relationship(\n    State(state): State<AppState>,\n    Path(concept_id): Path<Uuid>,\n    Json(req): Json<CreateRelationshipRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Prevent self-relationships\n    if concept_id == req.target_concept_id {\n        return Err(ApiError::validation(\"Cannot create relationship to self\"));\n    }\n    \n    // Check for cycles (if creating broader/narrower)\n    if matches!(req.relationship_type, SkosRelationshipType::Broader | SkosRelationshipType::Narrower) {\n        let would_create_cycle = state.skos_repo\n            .would_create_cycle(concept_id, req.target_concept_id, req.relationship_type)\n            .await\n            .map_err(ApiError::from_db)?;\n        \n        if would_create_cycle {\n            return Err(ApiError::validation(\"Would create circular relationship\"));\n        }\n    }\n    \n    // Create relationship (and inverse if applicable)\n    let relationship_id = state.skos_repo\n        .create_relationship(concept_id, req.target_concept_id, req.relationship_type)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    let relationship = state.skos_repo\n        .get_relationship(relationship_id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Relationship not found\"))?;\n    \n    Ok((StatusCode::CREATED, Json(RelationshipResponse::from(relationship))))\n}\n\nasync fn list_relationships(\n    State(state): State<AppState>,\n    Path(concept_id): Path<Uuid>,\n) -> Result<impl IntoResponse, ApiError> {\n    let relationships = state.skos_repo\n        .get_concept_relationships(concept_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    let response: Vec<RelationshipResponse> = relationships.into_iter()\n        .map(RelationshipResponse::from)\n        .collect();\n    \n    Ok(Json(response))\n}\n\nasync fn delete_relationship(\n    State(state): State<AppState>,\n    Path((concept_id, relationship_id)): Path<(Uuid, Uuid)>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Verify relationship belongs to concept\n    let relationship = state.skos_repo\n        .get_relationship(relationship_id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Relationship not found\"))?;\n    \n    if relationship.parent_id != concept_id && relationship.child_id != concept_id {\n        return Err(ApiError::not_found(\"Relationship not found for concept\"));\n    }\n    \n    // Delete relationship (and inverse if applicable)\n    state.skos_repo\n        .delete_relationship(relationship_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    Ok(StatusCode::NO_CONTENT)\n}\n```\n\n## Technical Notes\n\n- Broader/narrower are inverse relationships\n- Related relationships are symmetric\n- Use transactions for inverse relationship creation\n- Consider batch operations for bulk relationship management\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n- Issue #5: Hierarchy traversal (for cycle detection)\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["api", "relationships", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement SKOS Turtle export endpoint",
    "body": "## Description\n\nCreate REST API endpoint to export SKOS concepts as RDF Turtle format (W3C SKOS standard).\n\n## Acceptance Criteria\n\n- [ ] Route: `GET /api/v1/schemes/:id/export/turtle` - Export scheme as Turtle\n- [ ] Generate valid SKOS RDF Turtle syntax\n- [ ] Include all concepts, labels, and relationships\n- [ ] Include scheme metadata\n- [ ] Support filtering by concept subset\n- [ ] Content-Type: `text/turtle`\n- [ ] Content-Disposition header with filename\n- [ ] Validate output with RDF validator\n- [ ] Integration tests\n\n## Turtle Format Example\n\n```turtle\n@prefix skos: <http://www.w3.org/2004/02/skos/core#> .\n@prefix dc: <http://purl.org/dc/terms/> .\n@prefix ex: <http://example.org/matric/> .\n\nex:myScheme a skos:ConceptScheme ;\n    dc:title \"My Taxonomy\" ;\n    dc:description \"Example SKOS taxonomy\" .\n\nex:concept1 a skos:Concept ;\n    skos:inScheme ex:myScheme ;\n    skos:prefLabel \"Machine Learning\"@en ;\n    skos:altLabel \"ML\"@en ;\n    skos:narrower ex:concept2 .\n\nex:concept2 a skos:Concept ;\n    skos:inScheme ex:myScheme ;\n    skos:prefLabel \"Deep Learning\"@en ;\n    skos:broader ex:concept1 .\n```\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/routes/skos.rs\n\nuse axum::response::{Response, IntoResponse};\nuse axum::http::header;\n\nasync fn export_scheme_turtle(\n    State(state): State<AppState>,\n    Path(scheme_id): Path<Uuid>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Fetch scheme\n    let scheme = state.skos_repo\n        .get_scheme(scheme_id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Scheme not found\"))?;\n    \n    // Fetch all concepts in scheme\n    let concepts = state.skos_repo\n        .get_concepts_by_scheme(scheme_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    // Generate Turtle\n    let turtle = generate_turtle(&scheme, &concepts)?;\n    \n    let filename = format!(\"{}.ttl\", scheme.notation);\n    \n    Ok(Response::builder()\n        .header(header::CONTENT_TYPE, \"text/turtle; charset=utf-8\")\n        .header(\n            header::CONTENT_DISPOSITION,\n            format!(\"attachment; filename=\\\"{}\\\"\", filename),\n        )\n        .body(turtle)\n        .unwrap())\n}\n\nfn generate_turtle(\n    scheme: &SkosScheme,\n    concepts: &[ConceptWithLabelsAndRelationships],\n) -> Result<String, ApiError> {\n    let mut turtle = String::new();\n    \n    // Prefixes\n    turtle.push_str(\"@prefix skos: <http://www.w3.org/2004/02/skos/core#> .\\n\");\n    turtle.push_str(\"@prefix dc: <http://purl.org/dc/terms/> .\\n\");\n    turtle.push_str(&format!(\"@prefix ex: <http://example.org/matric/{}#> .\\n\\n\", scheme.notation));\n    \n    // Scheme definition\n    turtle.push_str(&format!(\"ex:{} a skos:ConceptScheme ;\\n\", scheme.notation));\n    turtle.push_str(&format!(\"    dc:title \\\"{}\\\" ;\\n\", escape_turtle(&scheme.title)));\n    if let Some(desc) = &scheme.description {\n        turtle.push_str(&format!(\"    dc:description \\\"{}\\\" ;\\n\", escape_turtle(desc)));\n    }\n    turtle.push_str(&format!(\"    dc:created \\\"{}\\\"^^xsd:dateTime .\\n\\n\", scheme.created_at.to_rfc3339()));\n    \n    // Concepts\n    for concept in concepts {\n        turtle.push_str(&format!(\"ex:{} a skos:Concept ;\\n\", concept.concept.notation));\n        turtle.push_str(&format!(\"    skos:inScheme ex:{} ;\\n\", scheme.notation));\n        \n        // Labels\n        for label in &concept.labels {\n            let property = match label.label_type {\n                SkosLabelType::PrefLabel => \"skos:prefLabel\",\n                SkosLabelType::AltLabel => \"skos:altLabel\",\n                SkosLabelType::HiddenLabel => \"skos:hiddenLabel\",\n            };\n            turtle.push_str(&format!(\n                \"    {} \\\"{}\\\"@{} ;\\n\",\n                property,\n                escape_turtle(&label.value),\n                label.language\n            ));\n        }\n        \n        // Relationships\n        for rel in &concept.relationships {\n            let property = match rel.relationship_type {\n                SkosRelationshipType::Broader => \"skos:broader\",\n                SkosRelationshipType::Narrower => \"skos:narrower\",\n                SkosRelationshipType::Related => \"skos:related\",\n            };\n            let target_notation = concepts.iter()\n                .find(|c| c.concept.id == rel.child_id || c.concept.id == rel.parent_id)\n                .map(|c| &c.concept.notation)\n                .unwrap_or(&\"unknown\".to_string());\n            turtle.push_str(&format!(\"    {} ex:{} ;\\n\", property, target_notation));\n        }\n        \n        // Remove trailing semicolon and add period\n        turtle = turtle.trim_end_matches(\" ;\\n\").to_string();\n        turtle.push_str(\" .\\n\\n\");\n    }\n    \n    Ok(turtle)\n}\n\nfn escape_turtle(s: &str) -> String {\n    s.replace('\\\\', \"\\\\\\\\\")\n        .replace('\"', \"\\\\\\\"\")\n        .replace('\\n', \"\\\\n\")\n        .replace('\\r', \"\\\\r\")\n}\n```\n\n## Technical Notes\n\n- Follow W3C SKOS specification strictly\n- Escape special characters in Turtle strings\n- Consider streaming for large schemes\n- Add Accept header negotiation for multiple formats\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n- Issue #5: Hierarchy traversal\n\n## Estimated Effort\n\nMedium (5-7 hours)",
    "labels": ["api", "export", "rdf", "priority-low", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement SKOS Turtle import endpoint",
    "body": "## Description\n\nCreate REST API endpoint to import SKOS concepts from RDF Turtle format.\n\n## Acceptance Criteria\n\n- [ ] Route: `POST /api/v1/schemes/:id/import/turtle` - Import Turtle file\n- [ ] Parse valid SKOS RDF Turtle syntax\n- [ ] Extract concepts, labels, and relationships\n- [ ] Create or update concepts (upsert logic)\n- [ ] Handle merge conflicts (notation collisions)\n- [ ] Validate RDF before import\n- [ ] Return import summary (created, updated, skipped, errors)\n- [ ] Transaction support (all or nothing)\n- [ ] OpenAPI documentation\n- [ ] Integration tests with sample Turtle files\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/dto/skos.rs\n\n#[derive(Debug, Serialize)]\npub struct ImportSummary {\n    pub concepts_created: usize,\n    pub concepts_updated: usize,\n    pub concepts_skipped: usize,\n    pub labels_created: usize,\n    pub relationships_created: usize,\n    pub errors: Vec<String>,\n}\n\n// In crates/matric-api/src/routes/skos.rs\n\nuse axum::extract::Multipart;\n\nasync fn import_scheme_turtle(\n    State(state): State<AppState>,\n    Path(scheme_id): Path<Uuid>,\n    mut multipart: Multipart,\n) -> Result<impl IntoResponse, ApiError> {\n    // Extract file from multipart\n    let mut turtle_content = String::new();\n    \n    while let Some(field) = multipart.next_field().await.map_err(|_| ApiError::bad_request(\"Invalid multipart\"))? {\n        if field.name() == Some(\"file\") {\n            turtle_content = field.text().await.map_err(|_| ApiError::bad_request(\"Failed to read file\"))?;\n            break;\n        }\n    }\n    \n    if turtle_content.is_empty() {\n        return Err(ApiError::bad_request(\"No file provided\"));\n    }\n    \n    // Parse Turtle (use RDF library like sophia or oxigraph)\n    let parsed = parse_turtle(&turtle_content)\n        .map_err(|e| ApiError::bad_request(format!(\"Invalid Turtle: {}\", e)))?;\n    \n    // Import concepts\n    let summary = state.skos_repo\n        .import_turtle(scheme_id, parsed)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    Ok(Json(summary))\n}\n\nfn parse_turtle(content: &str) -> Result<ParsedSkos, String> {\n    // Use RDF parsing library\n    // Example with sophia crate:\n    // let graph = sophia::parser::turtle::parse_str(content)?;\n    // Extract SKOS triples and build ParsedSkos\n    \n    unimplemented!(\"RDF parsing logic\")\n}\n\n#[derive(Debug)]\nstruct ParsedSkos {\n    concepts: Vec<ParsedConcept>,\n    relationships: Vec<ParsedRelationship>,\n}\n\n#[derive(Debug)]\nstruct ParsedConcept {\n    notation: String,\n    labels: Vec<(SkosLabelType, String, String)>,\n}\n\n#[derive(Debug)]\nstruct ParsedRelationship {\n    parent_notation: String,\n    child_notation: String,\n    relationship_type: SkosRelationshipType,\n}\n```\n\n## Technical Notes\n\n- Use RDF library: `oxigraph`, `sophia`, or `rio`\n- Handle namespace resolution\n- Validate SKOS semantics (required properties, constraints)\n- Consider incremental import for large files\n- Log detailed errors for debugging\n\n## Dependencies\n\n- Issue #4: SkosConceptRepository\n- Issue #12: SKOS Turtle export (for testing round-trip)\n\n## Estimated Effort\n\nLarge (8-10 hours)",
    "labels": ["api", "import", "rdf", "priority-low", "size-L"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Implement validation endpoint",
    "body": "## Description\n\nCreate REST API endpoint to validate SKOS concept hierarchies and detect anti-patterns.\n\n## Acceptance Criteria\n\n- [ ] Route: `POST /api/v1/schemes/:id/validate` - Validate entire scheme\n- [ ] Route: `POST /api/v1/concepts/:id/validate` - Validate single concept\n- [ ] Return validation result with errors and warnings\n- [ ] Include anti-pattern detection results\n- [ ] Support custom validation config in request body\n- [ ] Response includes affected concept IDs and suggestions\n- [ ] OpenAPI documentation\n- [ ] Integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/dto/skos.rs\n\nuse matric_core::validation::{ValidationConfig, ValidationResult};\n\n#[derive(Debug, Deserialize)]\npub struct ValidateRequest {\n    pub config: Option<ValidationConfig>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ValidateResponse {\n    pub valid: bool,\n    pub issues: Vec<ValidationIssueResponse>,\n    pub summary: ValidationSummary,\n}\n\n#[derive(Debug, Serialize)]\npub struct ValidationIssueResponse {\n    pub level: String,  // \"error\", \"warning\", \"info\"\n    pub code: String,\n    pub message: String,\n    pub concept_id: Option<Uuid>,\n    pub notation: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ValidationSummary {\n    pub total_concepts: usize,\n    pub error_count: usize,\n    pub warning_count: usize,\n    pub info_count: usize,\n}\n\n// In crates/matric-api/src/routes/skos.rs\n\nasync fn validate_scheme(\n    State(state): State<AppState>,\n    Path(scheme_id): Path<Uuid>,\n    Json(req): Json<ValidateRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    let config = req.config.unwrap_or_default();\n    \n    // Fetch all concepts in scheme\n    let concepts = state.skos_repo\n        .get_all_concepts_with_relationships(scheme_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    // Run validation\n    let validator = SkosValidator::new(config);\n    let result = validator.validate_hierarchy(&concepts);\n    \n    // Build response\n    let summary = ValidationSummary {\n        total_concepts: concepts.len(),\n        error_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Error)).count(),\n        warning_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Warning)).count(),\n        info_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Info)).count(),\n    };\n    \n    let issues: Vec<ValidationIssueResponse> = result.issues.into_iter()\n        .map(ValidationIssueResponse::from)\n        .collect();\n    \n    Ok(Json(ValidateResponse {\n        valid: result.valid,\n        issues,\n        summary,\n    }))\n}\n\nasync fn validate_concept(\n    State(state): State<AppState>,\n    Path(concept_id): Path<Uuid>,\n    Json(req): Json<ValidateRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    let config = req.config.unwrap_or_default();\n    \n    // Fetch concept with context (ancestors, descendants)\n    let concept = state.skos_repo\n        .get_concept_with_context(concept_id)\n        .await\n        .map_err(ApiError::from_db)?\n        .ok_or_else(|| ApiError::not_found(\"Concept not found\"))?;\n    \n    // Run validation\n    let validator = SkosValidator::new(config);\n    let result = validator.validate_concept(&concept);\n    \n    // Build response\n    let summary = ValidationSummary {\n        total_concepts: 1,\n        error_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Error)).count(),\n        warning_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Warning)).count(),\n        info_count: result.issues.iter().filter(|i| matches!(i.level, ValidationLevel::Info)).count(),\n    };\n    \n    let issues: Vec<ValidationIssueResponse> = result.issues.into_iter()\n        .map(ValidationIssueResponse::from)\n        .collect();\n    \n    Ok(Json(ValidateResponse {\n        valid: result.valid,\n        issues,\n        summary,\n    }))\n}\n```\n\n## Technical Notes\n\n- Validation should be fast (<1s for 1000 concepts)\n- Consider async validation for large schemes\n- Cache validation results with TTL\n- Provide actionable suggestions in messages\n\n## Dependencies\n\n- Issue #7: Validation types and anti-pattern detection\n- Issue #4: SkosConceptRepository\n\n## Estimated Effort\n\nMedium (4-5 hours)",
    "labels": ["api", "validation", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "MCP: Implement tag management tools",
    "body": "## Description\n\nImplement MCP tools for SKOS tag management (create, update, delete, get) in the Node.js MCP server.\n\n## Acceptance Criteria\n\n- [ ] Tools in `mcp-server/tools/tags.js`:\n  - [ ] `create_tag(notation, labels, scheme_id)` - Create new concept\n  - [ ] `update_tag(concept_id, notation, labels)` - Update concept\n  - [ ] `delete_tag(concept_id)` - Delete concept\n  - [ ] `get_tag(notation_or_id)` - Get concept details\n  - [ ] `list_tags(scheme_id, limit, offset)` - List concepts\n- [ ] Each tool calls matric-api REST endpoints\n- [ ] Error handling with user-friendly messages\n- [ ] Input validation\n- [ ] Tool descriptions for Claude\n- [ ] Integration tests\n\n## Implementation\n\n```javascript\n// In mcp-server/tools/tags.js\n\nconst axios = require('axios');\n\nconst API_BASE = process.env.MATRIC_API_URL || 'http://localhost:3000/api/v1';\n\nmodule.exports = {\n  name: 'create_tag',\n  description: 'Create a new SKOS tag/concept with labels',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      notation: {\n        type: 'string',\n        description: 'Unique lowercase identifier (e.g., \"machine-learning\")',\n        pattern: '^[a-z0-9][a-z0-9_-]*$'\n      },\n      pref_label: {\n        type: 'string',\n        description: 'Preferred label (e.g., \"Machine Learning\")'\n      },\n      alt_labels: {\n        type: 'array',\n        description: 'Alternative labels (synonyms)',\n        items: { type: 'string' },\n        default: []\n      },\n      scheme_id: {\n        type: 'string',\n        description: 'UUID of the scheme (namespace)',\n        format: 'uuid'\n      },\n      language: {\n        type: 'string',\n        description: 'ISO 639-1 language code',\n        default: 'en'\n      }\n    },\n    required: ['notation', 'pref_label', 'scheme_id']\n  },\n  async execute({ notation, pref_label, alt_labels = [], scheme_id, language = 'en' }) {\n    try {\n      // Build labels array\n      const labels = [\n        { label_type: 'prefLabel', language, value: pref_label },\n        ...alt_labels.map(label => ({ label_type: 'altLabel', language, value: label }))\n      ];\n      \n      const response = await axios.post(`${API_BASE}/concepts`, {\n        notation,\n        scheme_id,\n        labels\n      });\n      \n      return {\n        content: [{\n          type: 'text',\n          text: `Created tag \"${notation}\" with ID ${response.data.id}`\n        }],\n        data: response.data\n      };\n    } catch (error) {\n      throw new Error(`Failed to create tag: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n\nmodule.exports.get_tag = {\n  name: 'get_tag',\n  description: 'Get details of a SKOS tag/concept by notation or ID',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      identifier: {\n        type: 'string',\n        description: 'Tag notation (e.g., \"machine-learning\") or UUID'\n      }\n    },\n    required: ['identifier']\n  },\n  async execute({ identifier }) {\n    try {\n      // Determine if UUID or notation\n      const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(identifier);\n      \n      const endpoint = isUuid\n        ? `${API_BASE}/concepts/${identifier}`\n        : `${API_BASE}/concepts/notation/${identifier}`;\n      \n      const response = await axios.get(endpoint);\n      \n      const concept = response.data;\n      const prefLabel = concept.labels.find(l => l.label_type === 'prefLabel')?.value || concept.notation;\n      const altLabels = concept.labels.filter(l => l.label_type === 'altLabel').map(l => l.value);\n      \n      let text = `Tag: ${prefLabel} (${concept.notation})\\n`;\n      text += `ID: ${concept.id}\\n`;\n      if (altLabels.length > 0) {\n        text += `Alternative labels: ${altLabels.join(', ')}\\n`;\n      }\n      text += `Created: ${concept.created_at}`;\n      \n      return {\n        content: [{ type: 'text', text }],\n        data: concept\n      };\n    } catch (error) {\n      if (error.response?.status === 404) {\n        throw new Error(`Tag \"${identifier}\" not found`);\n      }\n      throw new Error(`Failed to get tag: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n\n// Additional tools: update_tag, delete_tag, list_tags...\n```\n\n## Technical Notes\n\n- Use axios for HTTP requests to matric-api\n- Validate inputs before API calls\n- Format responses for Claude readability\n- Handle API errors gracefully\n\n## Dependencies\n\n- Issue #8: Concept CRUD endpoints\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["mcp", "tools", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "MCP: Implement search and hierarchy tools",
    "body": "## Description\n\nImplement MCP tools for SKOS tag search, autocomplete, and hierarchy navigation.\n\n## Acceptance Criteria\n\n- [ ] Tools in `mcp-server/tools/tags.js`:\n  - [ ] `search_tags(query, scheme_id, limit)` - Full-text search\n  - [ ] `autocomplete_tags(prefix, scheme_id, limit)` - Autocomplete\n  - [ ] `get_tag_ancestors(notation_or_id)` - Get parent chain\n  - [ ] `get_tag_descendants(notation_or_id, depth)` - Get children\n  - [ ] `get_tag_tree(scheme_id, depth)` - Get full hierarchy\n  - [ ] `add_tag_relationship(parent, child, type)` - Create relationship\n- [ ] Formatted output for Claude consumption\n- [ ] Error handling\n- [ ] Tool descriptions\n- [ ] Integration tests\n\n## Implementation\n\n```javascript\n// In mcp-server/tools/tags.js\n\nmodule.exports.search_tags = {\n  name: 'search_tags',\n  description: 'Search for SKOS tags using full-text search across labels',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      query: {\n        type: 'string',\n        description: 'Search query'\n      },\n      scheme_id: {\n        type: 'string',\n        description: 'Optional scheme UUID to filter results',\n        format: 'uuid'\n      },\n      limit: {\n        type: 'integer',\n        description: 'Maximum results',\n        default: 20,\n        minimum: 1,\n        maximum: 100\n      }\n    },\n    required: ['query']\n  },\n  async execute({ query, scheme_id, limit = 20 }) {\n    try {\n      const params = new URLSearchParams({ q: query, limit });\n      if (scheme_id) params.append('scheme_id', scheme_id);\n      \n      const response = await axios.get(`${API_BASE}/concepts/search?${params}`);\n      \n      if (response.data.length === 0) {\n        return {\n          content: [{ type: 'text', text: `No tags found matching \"${query}\"` }]\n        };\n      }\n      \n      let text = `Found ${response.data.length} tags matching \"${query}\":\\n\\n`;\n      for (const result of response.data) {\n        text += `- ${result.matched_label} (${result.concept.notation})\\n`;\n        if (result.label_type === 'altLabel') {\n          const prefLabel = result.concept.labels.find(l => l.label_type === 'prefLabel')?.value;\n          if (prefLabel) text += `  Preferred label: ${prefLabel}\\n`;\n        }\n      }\n      \n      return {\n        content: [{ type: 'text', text }],\n        data: response.data\n      };\n    } catch (error) {\n      throw new Error(`Failed to search tags: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n\nmodule.exports.get_tag_tree = {\n  name: 'get_tag_tree',\n  description: 'Get hierarchical tree view of SKOS tags in a scheme',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      scheme_id: {\n        type: 'string',\n        description: 'Scheme UUID',\n        format: 'uuid'\n      },\n      depth: {\n        type: 'integer',\n        description: 'Maximum depth to traverse',\n        default: 5,\n        minimum: 1,\n        maximum: 10\n      }\n    },\n    required: ['scheme_id']\n  },\n  async execute({ scheme_id, depth = 5 }) {\n    try {\n      const response = await axios.get(`${API_BASE}/schemes/${scheme_id}/tree?depth=${depth}`);\n      \n      const formatTree = (nodes, indent = 0) => {\n        let text = '';\n        for (const node of nodes) {\n          const prefLabel = node.concept.labels.find(l => l.label_type === 'prefLabel')?.value || node.concept.notation;\n          text += `${'  '.repeat(indent)}- ${prefLabel} (${node.concept.notation})\\n`;\n          if (node.children.length > 0) {\n            text += formatTree(node.children, indent + 1);\n          }\n        }\n        return text;\n      };\n      \n      const text = `Tag hierarchy (depth ${depth}):\\n\\n${formatTree(response.data)}`;\n      \n      return {\n        content: [{ type: 'text', text }],\n        data: response.data\n      };\n    } catch (error) {\n      throw new Error(`Failed to get tag tree: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n\n// Additional tools: autocomplete_tags, get_tag_ancestors, get_tag_descendants, add_tag_relationship...\n```\n\n## Technical Notes\n\n- Format tree output for readability\n- Use indentation to show hierarchy\n- Include notation for disambiguation\n- Handle empty results gracefully\n\n## Dependencies\n\n- Issue #9: Search and autocomplete endpoints\n- Issue #10: Hierarchy tree endpoints\n- Issue #15: Tag management tools\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["mcp", "tools", "search", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "MCP: Implement export/import tools",
    "body": "## Description\n\nImplement MCP tools for SKOS Turtle export and import.\n\n## Acceptance Criteria\n\n- [ ] Tools in `mcp-server/tools/tags.js`:\n  - [ ] `export_tags_turtle(scheme_id, output_path)` - Export to Turtle file\n  - [ ] `import_tags_turtle(scheme_id, file_path)` - Import from Turtle file\n- [ ] File handling for Turtle format\n- [ ] Progress reporting for large imports\n- [ ] Error handling with detailed messages\n- [ ] Tool descriptions\n- [ ] Integration tests\n\n## Implementation\n\n```javascript\n// In mcp-server/tools/tags.js\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst FormData = require('form-data');\n\nmodule.exports.export_tags_turtle = {\n  name: 'export_tags_turtle',\n  description: 'Export SKOS tags to RDF Turtle format file',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      scheme_id: {\n        type: 'string',\n        description: 'Scheme UUID to export',\n        format: 'uuid'\n      },\n      output_path: {\n        type: 'string',\n        description: 'Output file path (will create .ttl file)'\n      }\n    },\n    required: ['scheme_id', 'output_path']\n  },\n  async execute({ scheme_id, output_path }) {\n    try {\n      // Ensure .ttl extension\n      if (!output_path.endsWith('.ttl')) {\n        output_path += '.ttl';\n      }\n      \n      // Fetch Turtle content from API\n      const response = await axios.get(`${API_BASE}/schemes/${scheme_id}/export/turtle`, {\n        responseType: 'text'\n      });\n      \n      // Write to file\n      await fs.writeFile(output_path, response.data, 'utf8');\n      \n      const stats = await fs.stat(output_path);\n      \n      return {\n        content: [{\n          type: 'text',\n          text: `Exported SKOS tags to ${output_path} (${stats.size} bytes)`\n        }]\n      };\n    } catch (error) {\n      throw new Error(`Failed to export tags: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n\nmodule.exports.import_tags_turtle = {\n  name: 'import_tags_turtle',\n  description: 'Import SKOS tags from RDF Turtle format file',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      scheme_id: {\n        type: 'string',\n        description: 'Target scheme UUID',\n        format: 'uuid'\n      },\n      file_path: {\n        type: 'string',\n        description: 'Path to Turtle (.ttl) file'\n      }\n    },\n    required: ['scheme_id', 'file_path']\n  },\n  async execute({ scheme_id, file_path }) {\n    try {\n      // Check file exists\n      await fs.access(file_path);\n      \n      // Read file\n      const fileContent = await fs.readFile(file_path, 'utf8');\n      \n      // Create multipart form data\n      const form = new FormData();\n      form.append('file', fileContent, {\n        filename: path.basename(file_path),\n        contentType: 'text/turtle'\n      });\n      \n      // Upload to API\n      const response = await axios.post(\n        `${API_BASE}/schemes/${scheme_id}/import/turtle`,\n        form,\n        {\n          headers: form.getHeaders()\n        }\n      );\n      \n      const summary = response.data;\n      \n      let text = `Import completed:\\n`;\n      text += `- Created: ${summary.concepts_created} concepts\\n`;\n      text += `- Updated: ${summary.concepts_updated} concepts\\n`;\n      text += `- Skipped: ${summary.concepts_skipped} concepts\\n`;\n      text += `- Labels: ${summary.labels_created} labels\\n`;\n      text += `- Relationships: ${summary.relationships_created} relationships\\n`;\n      \n      if (summary.errors.length > 0) {\n        text += `\\nErrors:\\n`;\n        for (const error of summary.errors.slice(0, 5)) {\n          text += `- ${error}\\n`;\n        }\n        if (summary.errors.length > 5) {\n          text += `... and ${summary.errors.length - 5} more errors\\n`;\n        }\n      }\n      \n      return {\n        content: [{ type: 'text', text }],\n        data: summary\n      };\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`File not found: ${file_path}`);\n      }\n      throw new Error(`Failed to import tags: ${error.response?.data?.message || error.message}`);\n    }\n  }\n};\n```\n\n## Technical Notes\n\n- Handle file I/O asynchronously\n- Validate file exists before import\n- Use multipart/form-data for file upload\n- Report import summary with statistics\n\n## Dependencies\n\n- Issue #12: SKOS Turtle export endpoint\n- Issue #13: SKOS Turtle import endpoint\n\n## Estimated Effort\n\nSmall (3-4 hours)",
    "labels": ["mcp", "tools", "import-export", "priority-low", "size-S"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "DB: Update note_tag table for SKOS integration",
    "body": "## Description\n\nUpdate `note_tag` table to reference `skos_concept` instead of flat `tag` table.\n\n## Acceptance Criteria\n\n- [ ] Migration file: `migrations/YYYYMMDD_note_tag_skos.sql`\n- [ ] Add `concept_id` column referencing `skos_concept.id`\n- [ ] Migrate existing `tag_name` references to `concept_id`\n- [ ] Drop `tag_name` column (after migration complete)\n- [ ] Update foreign key constraints\n- [ ] Update indices\n- [ ] Preserve `source` column (manual/auto)\n- [ ] Update note repository methods\n- [ ] Rollback script\n- [ ] Data integrity validation\n\n## Migration\n\n```sql\n-- Add concept_id column\nALTER TABLE note_tag ADD COLUMN concept_id UUID REFERENCES skos_concept(id) ON DELETE CASCADE;\n\n-- Migrate existing relationships\nUPDATE note_tag nt\nSET concept_id = c.id\nFROM tag t\nJOIN skos_concept c ON LOWER(t.name) = c.notation\nWHERE nt.tag_name = t.name;\n\n-- Verify no orphans\nDO $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM note_tag WHERE concept_id IS NULL) THEN\n        RAISE EXCEPTION 'Migration incomplete: orphaned note_tag entries exist';\n    END IF;\nEND $$;\n\n-- Make concept_id NOT NULL\nALTER TABLE note_tag ALTER COLUMN concept_id SET NOT NULL;\n\n-- Drop old tag_name column and constraint\nALTER TABLE note_tag DROP CONSTRAINT note_tag_tag_name_fkey;\nALTER TABLE note_tag DROP COLUMN tag_name;\n\n-- Update primary key\nALTER TABLE note_tag DROP CONSTRAINT note_tag_pkey;\nALTER TABLE note_tag ADD PRIMARY KEY (note_id, concept_id);\n\n-- Update indices\nDROP INDEX IF EXISTS idx_note_tag_tag;\nCREATE INDEX idx_note_tag_concept ON note_tag(concept_id);\n\n-- Drop old tag table (optional, consider keeping for backup)\n-- DROP TABLE tag CASCADE;\n```\n\n## Technical Notes\n\n- Verify all tags migrated before dropping columns\n- Keep old `tag` table temporarily for rollback\n- Update Rust models and repositories\n- Update API endpoints using tags\n\n## Dependencies\n\n- Issue #2: Migrate existing flat tags to SKOS\n- Issue #1: SKOS schema migration\n\n## Estimated Effort\n\nMedium (4-5 hours)",
    "labels": ["database", "migration", "integration", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "Core: Update note models for SKOS tags",
    "body": "## Description\n\nUpdate note-related models and repositories in `matric-core` and `matric-db` to use SKOS concepts instead of flat tags.\n\n## Acceptance Criteria\n\n- [ ] Update `Note` model to use `Vec<SkosConcept>` for tags\n- [ ] Update `NoteRepository` methods:\n  - [ ] `add_tag(note_id, concept_id, source)`\n  - [ ] `remove_tag(note_id, concept_id)`\n  - [ ] `get_note_tags(note_id) -> Vec<ConceptWithLabels>`\n  - [ ] `find_notes_by_tag(concept_id) -> Vec<Note>`\n- [ ] Update existing queries to join `skos_concept` and `skos_label`\n- [ ] Maintain backward compatibility where possible\n- [ ] Update unit tests\n- [ ] Update integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-core/src/models.rs\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct Note {\n    pub id: Uuid,\n    pub collection_id: Option<Uuid>,\n    pub format: String,\n    pub source: String,\n    pub created_at_utc: DateTime<Utc>,\n    pub updated_at_utc: DateTime<Utc>,\n    pub starred: bool,\n    pub archived: bool,\n    pub title: Option<String>,\n    // Tags are fetched separately via repository\n}\n\n// In crates/matric-db/src/repositories/note.rs\n\nimpl NoteRepository {\n    pub async fn add_tag(\n        &self,\n        note_id: Uuid,\n        concept_id: Uuid,\n        source: &str,\n    ) -> Result<(), DbError> {\n        sqlx::query(\n            \"INSERT INTO note_tag (note_id, concept_id, source) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING\"\n        )\n        .bind(note_id)\n        .bind(concept_id)\n        .bind(source)\n        .execute(&self.pool)\n        .await?;\n        \n        Ok(())\n    }\n    \n    pub async fn get_note_tags(\n        &self,\n        note_id: Uuid,\n    ) -> Result<Vec<ConceptWithLabels>, DbError> {\n        let concepts = sqlx::query_as::<_, SkosConcept>(\n            r#\"\n            SELECT c.*\n            FROM skos_concept c\n            JOIN note_tag nt ON nt.concept_id = c.id\n            WHERE nt.note_id = $1\n            ORDER BY c.notation\n            \"#\n        )\n        .bind(note_id)\n        .fetch_all(&self.pool)\n        .await?;\n        \n        let mut result = Vec::new();\n        for concept in concepts {\n            let labels = sqlx::query_as::<_, SkosLabel>(\n                \"SELECT * FROM skos_label WHERE concept_id = $1\"\n            )\n            .bind(concept.id)\n            .fetch_all(&self.pool)\n            .await?;\n            \n            result.push(ConceptWithLabels { concept, labels });\n        }\n        \n        Ok(result)\n    }\n    \n    pub async fn find_notes_by_tag(\n        &self,\n        concept_id: Uuid,\n        limit: i64,\n        offset: i64,\n    ) -> Result<Vec<Note>, DbError> {\n        let notes = sqlx::query_as::<_, Note>(\n            r#\"\n            SELECT n.*\n            FROM note n\n            JOIN note_tag nt ON nt.note_id = n.id\n            WHERE nt.concept_id = $1\n              AND n.deleted_at IS NULL\n            ORDER BY n.updated_at_utc DESC\n            LIMIT $2 OFFSET $3\n            \"#\n        )\n        .bind(concept_id)\n        .bind(limit)\n        .bind(offset)\n        .fetch_all(&self.pool)\n        .await?;\n        \n        Ok(notes)\n    }\n}\n```\n\n## Technical Notes\n\n- Eager vs lazy loading of labels (consider performance)\n- Update API DTOs to include full concept information\n- Maintain `source` field for manual vs auto tags\n\n## Dependencies\n\n- Issue #18: Update note_tag table for SKOS integration\n- Issue #3: SKOS Rust types\n\n## Estimated Effort\n\nMedium (5-7 hours)",
    "labels": ["core", "database", "integration", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "API: Update note endpoints for SKOS tags",
    "body": "## Description\n\nUpdate note-related API endpoints to work with SKOS concepts instead of flat tags.\n\n## Acceptance Criteria\n\n- [ ] Update endpoints:\n  - [ ] `POST /api/v1/notes/:id/tags` - Add SKOS tag to note (accept concept_id or notation)\n  - [ ] `DELETE /api/v1/notes/:id/tags/:concept_id` - Remove tag from note\n  - [ ] `GET /api/v1/notes/:id/tags` - Get note's SKOS tags with labels\n  - [ ] `GET /api/v1/notes?tag=concept_id` - Filter notes by SKOS tag\n- [ ] Request DTOs accept both concept_id and notation\n- [ ] Response DTOs include full concept with prefLabel\n- [ ] Backward compatibility with legacy tag queries (if needed)\n- [ ] OpenAPI documentation updated\n- [ ] Integration tests\n\n## Implementation\n\n```rust\n// In crates/matric-api/src/dto/note.rs\n\n#[derive(Debug, Deserialize)]\npub struct AddTagRequest {\n    #[serde(flatten)]\n    pub identifier: TagIdentifier,\n    pub source: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(untagged)]\npub enum TagIdentifier {\n    ConceptId { concept_id: Uuid },\n    Notation { notation: String },\n}\n\n#[derive(Debug, Serialize)]\npub struct NoteTagResponse {\n    pub concept_id: Uuid,\n    pub notation: String,\n    pub pref_label: String,\n    pub alt_labels: Vec<String>,\n    pub source: String,\n}\n\n// In crates/matric-api/src/routes/notes.rs\n\nasync fn add_tag_to_note(\n    State(state): State<AppState>,\n    Path(note_id): Path<Uuid>,\n    Json(req): Json<AddTagRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Resolve concept_id from notation if needed\n    let concept_id = match req.identifier {\n        TagIdentifier::ConceptId { concept_id } => concept_id,\n        TagIdentifier::Notation { notation } => {\n            let concept = state.skos_repo\n                .get_by_notation(&notation)\n                .await\n                .map_err(ApiError::from_db)?\n                .ok_or_else(|| ApiError::not_found(format!(\"Tag '{}' not found\", notation)))?;\n            concept.concept.id\n        }\n    };\n    \n    // Add tag to note\n    state.note_repo\n        .add_tag(note_id, concept_id, req.source.as_deref().unwrap_or(\"manual\"))\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    Ok(StatusCode::NO_CONTENT)\n}\n\nasync fn get_note_tags(\n    State(state): State<AppState>,\n    Path(note_id): Path<Uuid>,\n) -> Result<impl IntoResponse, ApiError> {\n    let tags = state.note_repo\n        .get_note_tags(note_id)\n        .await\n        .map_err(ApiError::from_db)?;\n    \n    let response: Vec<NoteTagResponse> = tags.into_iter()\n        .map(|concept_with_labels| {\n            let pref_label = concept_with_labels.labels\n                .iter()\n                .find(|l| l.label_type == SkosLabelType::PrefLabel)\n                .map(|l| l.value.clone())\n                .unwrap_or_else(|| concept_with_labels.concept.notation.clone());\n            \n            let alt_labels = concept_with_labels.labels\n                .iter()\n                .filter(|l| l.label_type == SkosLabelType::AltLabel)\n                .map(|l| l.value.clone())\n                .collect();\n            \n            NoteTagResponse {\n                concept_id: concept_with_labels.concept.id,\n                notation: concept_with_labels.concept.notation,\n                pref_label,\n                alt_labels,\n                source: \"manual\".to_string(),  // TODO: fetch from note_tag\n            }\n        })\n        .collect();\n    \n    Ok(Json(response))\n}\n\n#[derive(Debug, Deserialize)]\npub struct ListNotesQuery {\n    pub tag: Option<Uuid>,  // concept_id\n    pub tag_notation: Option<String>,\n    pub limit: Option<i64>,\n    pub offset: Option<i64>,\n    // ... other filters\n}\n\nasync fn list_notes(\n    State(state): State<AppState>,\n    Query(params): Query<ListNotesQuery>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Resolve tag filter\n    let concept_id = if let Some(id) = params.tag {\n        Some(id)\n    } else if let Some(notation) = params.tag_notation {\n        let concept = state.skos_repo\n            .get_by_notation(&notation)\n            .await\n            .map_err(ApiError::from_db)?\n            .ok_or_else(|| ApiError::not_found(format!(\"Tag '{}' not found\", notation)))?;\n        Some(concept.concept.id)\n    } else {\n        None\n    };\n    \n    let notes = if let Some(cid) = concept_id {\n        state.note_repo\n            .find_notes_by_tag(cid, params.limit.unwrap_or(50), params.offset.unwrap_or(0))\n            .await\n            .map_err(ApiError::from_db)?\n    } else {\n        // ... regular listing\n        vec![]\n    };\n    \n    Ok(Json(notes))\n}\n```\n\n## Technical Notes\n\n- Accept both concept_id and notation for flexibility\n- Return full concept information in responses\n- Consider deprecation path for old tag API\n\n## Dependencies\n\n- Issue #19: Update note models for SKOS tags\n- Issue #8: Concept CRUD endpoints\n\n## Estimated Effort\n\nMedium (5-6 hours)",
    "labels": ["api", "integration", "priority-high", "size-M"],
    "milestone": null,
    "assignee": null
  },
  {
    "title": "Docs: Create comprehensive tags documentation",
    "body": "## Description\n\nCreate comprehensive documentation for SKOS hierarchical tag system in `docs/tags.md`.\n\n## Acceptance Criteria\n\n- [ ] Document file: `docs/tags.md`\n- [ ] Sections:\n  - [ ] Overview of SKOS concepts\n  - [ ] Tag hierarchy best practices\n  - [ ] API usage examples\n  - [ ] MCP tool examples\n  - [ ] Turtle import/export guide\n  - [ ] Validation and anti-patterns\n  - [ ] Migration from flat tags\n  - [ ] Common patterns and examples\n  - [ ] Troubleshooting\n- [ ] Code examples for all API endpoints\n- [ ] MCP tool usage examples\n- [ ] Diagrams for hierarchy visualization\n- [ ] Link to W3C SKOS specification\n\n## Documentation Outline\n\n```markdown\n# SKOS Hierarchical Tag System\n\n## Overview\n\nMatric Memory uses W3C SKOS (Simple Knowledge Organization System) for hierarchical tag management.\n\n### Key Concepts\n\n- **Concept**: A tag with unique notation and multilingual labels\n- **Scheme**: A namespace/taxonomy for organizing concepts\n- **Label Types**:\n  - prefLabel: Primary label (one per language)\n  - altLabel: Alternative labels (synonyms)\n  - hiddenLabel: Search terms (not displayed)\n- **Relationships**:\n  - broader/narrower: Hierarchical (parent/child)\n  - related: Associative (sibling/cross-reference)\n\n## Creating Tags\n\n### Via API\n\n```bash\ncurl -X POST http://localhost:3000/api/v1/concepts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"notation\": \"machine-learning\",\n    \"scheme_id\": \"uuid-here\",\n    \"labels\": [\n      { \"label_type\": \"prefLabel\", \"language\": \"en\", \"value\": \"Machine Learning\" },\n      { \"label_type\": \"altLabel\", \"language\": \"en\", \"value\": \"ML\" }\n    ]\n  }'\n```\n\n### Via MCP (Claude)\n\n```\nPlease create a tag \"deep-learning\" with label \"Deep Learning\" as a child of \"machine-learning\"\n```\n\n## Building Hierarchies\n\n### Example Taxonomy\n\n```\nAI\n Machine Learning\n    Deep Learning\n       CNNs\n       RNNs\n    Traditional ML\n        Decision Trees\n        SVM\n Knowledge Representation\n     Ontologies\n```\n\n### Creating Relationships\n\n```bash\ncurl -X POST http://localhost:3000/api/v1/concepts/{parent-id}/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"target_concept_id\": \"child-id\",\n    \"relationship_type\": \"narrower\"\n  }'\n```\n\n## Best Practices\n\n### Notation Guidelines\n\n- Use lowercase kebab-case: `machine-learning`\n- Be descriptive but concise\n- Avoid abbreviations in notation (use altLabels instead)\n- Use hierarchy sparingly (max depth: 5)\n\n### Hierarchy Design\n\n- Keep breadth reasonable (<20 children per parent)\n- Avoid single-child parents\n- Use related relationships for cross-references\n- Mark top-level concepts explicitly\n\n### Anti-Patterns to Avoid\n\n- **Over-nesting**: Too deep hierarchies (>5 levels)\n- **Meta-tags**: Tags about tags (e.g., \"tag-management\")\n- **Orphans**: Concepts without parent or scheme\n- **Duplicate labels**: Same prefLabel for different concepts\n\n## Validation\n\n```bash\ncurl http://localhost:3000/api/v1/schemes/{scheme-id}/validate\n```\n\nExample response:\n```json\n{\n  \"valid\": false,\n  \"issues\": [\n    {\n      \"level\": \"warning\",\n      \"code\": \"OVER_NESTING\",\n      \"message\": \"Concept depth 6 exceeds recommended maximum 5\",\n      \"concept_id\": \"uuid\"\n    }\n  ]\n}\n```\n\n## Import/Export\n\n### Export to Turtle\n\n```bash\ncurl http://localhost:3000/api/v1/schemes/{scheme-id}/export/turtle > taxonomy.ttl\n```\n\n### Import from Turtle\n\n```bash\ncurl -X POST http://localhost:3000/api/v1/schemes/{scheme-id}/import/turtle \\\n  -F \"file=@taxonomy.ttl\"\n```\n\n## MCP Tools Reference\n\n| Tool | Description |\n|------|-------------|\n| `create_tag` | Create new SKOS concept |\n| `get_tag` | Get concept by notation/ID |\n| `search_tags` | Full-text search across labels |\n| `autocomplete_tags` | Prefix-based autocomplete |\n| `get_tag_tree` | Get hierarchy tree |\n| `add_tag_relationship` | Create parent/child relationship |\n| `export_tags_turtle` | Export to RDF Turtle |\n| `import_tags_turtle` | Import from RDF Turtle |\n\n## Migration from Flat Tags\n\nExisting flat tags are automatically migrated to SKOS concepts in the 'legacy' scheme with these transformations:\n- Tag name  notation (lowercased)\n- Tag name  prefLabel (original case)\n- All tags are top-level concepts\n\nTo organize migrated tags:\n1. Create new schemes for different taxonomies\n2. Move concepts to appropriate schemes\n3. Add broader/narrower relationships\n4. Add alternative labels for synonyms\n\n## Troubleshooting\n\n### \"Notation already exists\"\n\nNotations must be unique. Use different notation or update existing concept.\n\n### \"Would create circular relationship\"\n\nCannot create parent-child relationship that would cause a cycle.\n\n### \"Concept not found\"\n\nVerify concept exists and notation is correct (case-sensitive for IDs).\n\n## References\n\n- [W3C SKOS Specification](https://www.w3.org/TR/skos-reference/)\n- [SKOS Primer](https://www.w3.org/TR/skos-primer/)\n```\n\n## Dependencies\n\nAll implementation issues completed\n\n## Estimated Effort\n\nMedium (6-8 hours)",
    "labels": ["documentation", "priority-medium", "size-M"],
    "milestone": null,
    "assignee": null
  }
]
